
echo  -e  1."aaa$1bb\\"    2. "\033[ 41; 31 mtest\033[ 0 m"
	1.\b  \c  \n  \f  \v  \t  \r  \\
	2. 40-47背景 30-37字体   0/1/4/5/7/8  #在第一第二部分则表示作用于内容，在第三部分则表示作用于终端

seq [-s +] [-w] 1 [2 10]
seq -f "dir%g" ["%03g"]  5

printf "%s [%s...]\n" a 1 b 2 c 3  # %3.2f\n
grep -i(忽略大小写) -v(取反) -n(显示行数) -c(统计) -o(仅输出匹配关键词) -ABC(上下文) -w(匹配单词) -e(支持正则) -q(静默)   (grep(基本正则) egrep(正则) fgrep(速度快不支持正则))

AWK:
	awk匹配模式有两种: 
		1. /正则/  
		2. 关系运算匹配  > < <= >= == != ~ !~    #注意，这是不用//
			'$3<50'  
			'$7!="/bin/bash"'   
			'$3 ~ /[0-9]{3,}/'  
			'$1=="ftp" || $1=="mail"{print $0}'
		3.行范围匹配	
	awk '{ip[$1]++}END{for(i in ip){print i,ip[i]}}' access.log-20190801 | column -t								 #统计ip	
	awk -F[:] 'BEGIN{i=0;j=0} {if($3<500){i++}else if($3>=500&&$3<1000){j++} else{k++}} END{print i,j,k}' passwd     #自定义变量：i=0;j=0,这是有逻辑的(将其中一个500改成100)
	awk 'BEGIN {max = 0} {if ($1>max) max=$1 fi} END {print "Max=", max}' data  #求最大值  最值：awk '{if($1>max){max=$1}else if($1<3){min=$1}}END{print "MAX =",max"\n""MIN =",min}' data
	awk 'BEGIN{sum=0}/^$/{++sum}END{print sum}' /etc/services                        #统计空行
	awk 'BEGIN{printf "%-20s%-20s%-20s%-20s%-20s%-20s\n","Name","Chinese","English","Math","Physical","Average"}{sum=$2+$3+$4+$5;avg=sum/4}{printf "%-20s%-20d%-20d%-20d%-20d%-0.2f\n",$1,$2,$3,$4,$5,avg}' student.txt #统计平均值,逗号表示字符串分隔符，分号表示命令分隔符
	awk占位符%[modifier]control-letter  -减号是左对齐,+加号是右对齐,#显示8进制在前面加0,显示16进制在前面加0x 
三元运算：	
	awk -F: '{usertype=$3<500?"系统用户":"普通用户" ; print $1,usertype}' passwd   #等同于awk -F: '{usertype=$3<500?"系统用户":"普通用户"}{ print $1,usertype}' passwd
	awk -F: '{uid=$3>500?a++:b++}END{print "普通用户总数:" a "\n" "系统用户总数 :",b}' passwd
	awk 'i=!i' test（打印奇数行）  /   awk '{i=!i;print i}' test
	 
	c	将一个数作为ASCII字符显示
	d	显示一个整数值
	i	显示一个整数值（和d一样）
	e	用科学计数法显示一个数
	f	显示一个浮点值
	g	用科学计数法或浮点数显示（选择一个较短的格式）
	o	显示一个八进制值
	s	显示一个文本字符串
	x	显示一个十六进制值
	X	显示一个十六进制值，但用大写字母A～F
	
	内置变量：
		$0                    打印行所有信息
		$1~$n                    打印行的第1到n个字段信息
		NF Number Field                处理行的字段个数
		NR Number Row                处理行的行号
		FNR File Number Row            多文件处理时，每个文件单独记录行号
		FS Field Separator            字段分隔符，不指定时默认以空格或tab键分割,指定\n被当作空格
		RS Row Separator            行分隔符，不指定时以回车换行分割,指定\n被当作空格
		OFS Output Filed Separator        输出字段分隔符
		ORS Output Row Separator        输出行分隔符
		FILENAME                处理文件的文件名
		ARGC                    命令行参数个数
		ARGV                    命令行参数数组	
awk [-v FS="#" -v OFS='---' -v RS=" " -v ORS="++"] '{print $1 $2}/{print FILENAME,$1,$2}'  test		
awk '{print NR/FNR/NF,$0,ARGV[0],ARGV[1],ARGV[2],ARGC}' test test1
abc=666  awk -v myvar=$abc 'BEGIN{print myvar}'	
awk [--re-interval] '/ro{1,2}t/{print $0}' passwd   #--re-interval 匹配指定次数,但自己试的时候不用加也可以
awk '/shutdown/,/operator/{print NR,$0}' passwd			#范围性输出，输出第一个匹配/root/和/operator/之间(包括)的行
awk 'NR>=3&&NR<=6{print NR,$0}' passwd					#3-6行	
cat -n passwd|awk -F: '{print $1}{print NR}'		#对于一行，输出$1再输出$2 等同于cat -n passwd|awk -F: '{print $1;print NR}'	
awk '($1~/[0-9]/&&$2~/[0-9]/)||($3~/[a-zA-Z]/){print $0}' awk.txt  #与或	
	内置函数
		rand，srand，int
		gsub  sub  length  index
		awk 'BEGIN{srand();print rand()}'   	 	awk 'BEGIN{srand();print int(100*rand())}'	  #随机数
		awk '{gsub("a","A");print $0}' passwd    	awk '{gsub("[a-z]","6");print $0}' passwd     #替换
		awk '{sub("[a-z]","6");print $0}' passwd	#替换	awk '{print $0,length()}' passwd	#字符串长度
		awk '{print index($0,"root")}' passwd   #root所在位置


		
	
	
TCPDUMP:  or/and/not
	tcpdump -D | less [类型：host，net，port，portrange  方向：src，dst  协议：tcp，udp，IP，vlan，arp... 多条件组合：and，or，not]
	tcpdump (-i 接口) (-c 抓包总数) (or/and/not) (-w 文件) (-r 指定文件读出) (port PORT) (src/dst host ip/域名/网络位) (-p 协议) -t(不显示时间戳) -vv(详细输出) -nn(不dns)  #可以用'(条件)'形成复合条件,高级过滤方式proxy[x:y]...	
	
	
LSOF：	匹配内容^表示取反 (/path/filename) (+d/+D dir) (-d fd) (-c <进程名> -c ...) (-u 用户名) (-p PID,PID...) (-i :port / 协议 / 协议:port/ 协议@url:服务名 / 协议@url:port ) -U(socket) -n(不dns) +/-r(持续) #协议指tcp和udp
	lsof | head
		COMMAND     PID   TID    USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
		删除恢复：
			1.lsof |grep /var/log/messages  
				USER使用COMMAND命令启动服务，进程ip是PID，线程id是TID，在DEVICE对类型TYPE，总大小SIZE，在磁盘上的索引节点NODE的文件NAME使用FD(文件描述符+操作方式)操作
			2.cat /proc/PID/fd/FD  >  <filename>

NC：
服务端         						客户端(-u:udp -v:版本/连接信息  -z:不发送数据  -w:超时时间)
nc -lv 9999 (tcp)					nc -vzw 2 192.168.3.6 9999（telnet 192.168.3.6 9999 / nmap 192.168.3.6 -p 9999）
nc -ul 9999(udp)					nc -uvzw 2 192.168.3.6 9998
									nmap -sU 192.168.3.6 -p 9998 -Pn    （-sU扫描udp端口，-Pn防止部分防火墙影响）
nc -lv 9995 > clent.txt(接收端)     nc -vzw 2 192.168.3.21 9995 < nc.txt(发送端)    --- 传文件
可以传目录
nc -l 9991 >/dev/null				nc 192.168.3.21 9991 </dev/zero  +  dstat  ---  测网速



	

              nc -l 1567 | tee test              nc 172.31.100.7 1567     
              nc -l 1567 < file.txt              nc -n 172.31.100.7 1567 > file.txt
	tar -cvf – dir_name| bzip2 -z | nc -l 1567   nc -n 172.31.100.7 1567 | bzip2 -d |tar -xvf -
	nc localhost 1567 | mcrypt –flush –bare -F -q -d -m ecb > file.txt    mcrypt –flush –bare -F -q -m ecb < file.txt | nc -l 1567	
	
	
cpu:top/lscpu	  top -H -p PID 查看进程下的线程 
ps -ef/-aux
	
	
ps -aux 的STAT
	S等待态(可中断)  D等待态(不可中断)  T等待态(暂停状态/后台挂起)  R运行态(包含就绪态)  Z僵尸进程
	<高优先级进程  N优先级较低  l有子进程  s会话组组长(一组会话组)  +前台进程(当前终端运行，可直接运行的进程)
ps -ajx/ef  查看父进程	
	进程优先级NI：决定一个进程的执行权限和占有资源的优先程度
		指定优先级运行程序命令：nice  -n  进程   (n取值：-20~19)
	
进程间通信方法：
	1.管道通信(pipe):
		通信原理： 在内存中开辟管道空间，生成管道操作对象，多个进程使用"同一个"管道对象进行操作即可实现通信(父进程创建，子进程继承)   
	2.消息队列(Queue)：先进先出
		通信原理：在内存中建立队列数据结构模型，多个进程都可以通过队列存入内容，取出内容的顺序和存入顺序保持一致
	3.共享内存(Shared memory)：
		通信原理：在内存中开辟一块空间，对多个进程可见，进程可以写入输出，但是每次写入的内容会覆盖之前的内容
	4.信号通信(内核发出的)：信号通信中唯一一种异步通信方法
		一个进程向另一个进程发送一个信号来传递某种讯息，接受者根据收到的信号进行相应的行为
			kill -l   查看系统信号
			sighup:终端关闭    sigint:ctrl-C终止   sigquit:ctrl-\终止    sigill/sigfpe:执行指令/算术运算错误终止  sigalrm:时钟信号
			sigkill:立即结束   sigstop:暂停       sigtstp:ctrl-z暂停    sigchld:子进程改变状态发信号给父进程   sigabort:结束进程     
	5.信号量:   
	6.套接字：本地套接字		
	
	元字符使用：
	元字符：
		a  						单个字符，包括汉字    
		|  						或(已匹配过的字符，就不会再匹配)
		.  						匹配除换行外的任意字符
		^  						匹配字符串的开始位置
		$  						匹配字符串的结束位置
		*  						匹配前一个字符出现0次或多次
		+  						匹配前一个字符出现1次或多次
		？ 						匹配前一个字符出现0次或1次
		{n}						匹配n次重复次数
		{m,n}       			匹配m到n次重复次数(包含mn)
		.+/.*       			匹配全部
		[字符集]    			匹配字符集中任意一个字符([_a-zA-Z0-9])
		[^字符集]   			过滤，即除字符集外的任意字符
		\d == [0-9]				匹配任意数字字符
		\D == [^0-9]			匹配任意非数字字符
		\w                      普通字符(字母数字下划线及汉字)
		\W						非普通字符
		\s						匹配任意空字符[\r\t\n\v\f ]
		\S                      匹配任意非空字符
		\A == ^                 匹配字符串的开始位置
		\Z == $                 匹配字符串的结束位置
		\b						匹配单词边界位置(普通字符和非普通字符交界认为是单词边界)
		\B						匹配非单词边界位置
		
	匹配单个字符： a . \d \D \w \W \s \S [..] [^..] 	
	匹配重复：*  +  ?  {n}	 {m,n}
	匹配位置:  ^  $  \A  \Z  \b  \B
	其它： |  ()  \
		
	绝对匹配：
		正则表达式要完全匹配目标字符串内容(\d+  --- "123"(完全匹配)  "as123df"(不是))
		"^正则表达式$"    在正则表达式开始和结束位置加上^$
		
	正则表达式转义：	
	
	raw字串：原始字符串对内容不解释转义，就表达内容原本意义
		
	贪婪与非贪婪：	
		贪婪模式：正则表达式的重复匹配总是尽可能多的向后匹配更多内容
			*  +  ?  {3,5}
				re.findall(r"ab{3,5}","abbbbbb")   --->  结果：['abbbbb']
		非贪婪模式(懒惰模式)：尽可能少的匹配内容
			*?  +?  ??  {3,5}?
				re.findall(r"ab*?","abbbbbb")   --->  结果：['a']
	
	正则表达式的子组：
		可以使用()为正则表达式建立子组，子组可以看作是正则表达式内部操作的一个整体，即先匹配整体，在内部子组匹配
			子组是在正则表达式整体匹配到内容的前提下才会发挥作用，不影响正则表达式整体去匹配目标内容这一原则
		re.findall(r"(ab)*","ababab")    #()会将ab当作一个整体
	
		子组所用：
			1.作为内部整体可以改变某些元字符的行为(正则)
				re.search(r"\w+@\w+\.(com|cn)","abc@123.com").group()   ---  'abc@123.com'
				re.search(r"\w+@\w+\.(com|cn)","abc@123.cn").group()	---  'abc@123.cn'
				re.search(r"\w+@\w+\.com|cn","abc@123.com").group()		---  'abc@123.com'
				re.search(r"\w+@\w+\.com|cn","abc@123.cn").group()		---  'cn'
			2.子组在某些操作中可以单独提取出匹配内容(编程)
				re.search(r"(https|http|ftp)://\S+","https://www.baidu.com").group()   ---  'https://www.baidu.com'
				re.search(r"(https|http|ftp)://\S+","https://www.baidu.com").group(1)  ---  'https'
		子组注意事项：
			1.一个正则表达式中可以有多个子组
			2.子组一般由外到内，由左到右称之为第一组，第二组...
			3.子组不能重叠，嵌套也不宜很多
	
	捕获组和非捕获组
		格式：(?P<name>pattern)
			作用：可以通过组名更方便获取某组内容
				re.search(r"(?P<dog>ab)cdef",'abcdef').group('dog')
	
	
	
	
	