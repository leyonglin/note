  
 [表达式] {变量/变量处理}  (子组/整体)

 echo  -e  1."aaa$1bb\\"    2. "\033[ 41; 31 mtest\033[ 0 m"
	1.\b  \c  \n  \f  \v  \t  \r  \\
	2. 40-47背景 30-37字体   0/1/4/5/7/8  #在第一第二部分则表示作用于内容，在第三部分则表示作用于终端
 
 seq [-s +] [-w] 1 [2 10]  		 #for i in `seq 1 2 10`; do echo $i; done
 seq -f "dir%g" ["%03g"]  5
 
 printf '\x45\n'
 printf "%s [%s...]\n" a 1 b 2 c 3  # %3.2f\n
 grep -i(忽略大小写) -v(取反) -n(显示行数) -c(统计) -o(仅输出匹配关键词) -ABC(上下文) -w(匹配单词) -e(支持正则) -q(静默)   (grep(基本正则) egrep(正则) fgrep(速度快不支持正则))
 grep -n '[^[:lower:]]oo' regular_express.txt
 egrep -n 'o\{2\}' regular_express.txt
 
 批量注释： :<<'#'  command  #
 ！！！脚本是重复改变但有规律的事情，例：pool${i}/config/.git
 man bash 如果写shell脚本一定要提前阅读该说明
 
 debug模式：
 #!/bin/bash   或者 #!/usr/bin/env bash
 set -e        执行错误即退出(man bash查看该命令错误的定义)
 set -x        输出执行代码(变量会被替换)与执行结果
 set -v        输出执行的命令
               shellcheck,不写进代码行中,代码检测网站https://www.shellcheck.net/，也可以下载命令行，并且可以集成到编辑器中(但是效果并不是很好)
 			  变量操作(man bash  全文查找Parameter Expansion)
               函数中，局部变量加local
               trap信号(trap sighandler INT)
 			  https://explainshell.com/执行过程
 2. sh [-nvx] scripts.sh
 -n  ：不要运行 script，仅查询语法的问题；
 -x  ：将使用到的 script 内容显示到萤幕上，这是很有用的参数！
 -v  ：再运行 sccript 前，先将 scripts 的内容输出到萤幕上；
 

 
 exec 3<>hello.txt	        hello.txt以读写方式绑定到文件描述符"3"
 echo "hello exec"  >&3      写进文件描述符3(第一次覆盖，后面追加)，相当于写进hello.txt
 exec 3>&-  关闭写    exec 3<&- 关闭读
 
 exec 100>&1    将文件描述符100连接到标准输出    exec 1>hello.txt # 将输出重定向到文件hello.txt
 exec 1>&100 100>&- # 将标准输出连接到100    将描述符100关了
 a<b   表示从b重定向输入到a			  
			  
			  
 add_db_master_ip () {
 # add master db ip address, run in slave database server
     while true;do
         read -p "请输入主库所有IP地址:" db_master_ip
         read -p "主库IP地址为:$db_master_ip 确定吗(y/n)" db_master_ip_yn
         case $db_master_ip_yn in
         y|Y)
         dbmasterip=$db_master_ip
         break;;
         n|N)
         continue;;
         esac
     done
 }	
 
 
 for i in $ip;do
 expect << EOF
         spawn /opt/apps/mysql/bin/mysql -uroot -p -S /opt/data/data_16303/mysql.sock -e "    
         grant all privileges on gameplat_analysis.* TO 'gameplat_analysis_dev'@'$i' identified by 'xjVXkB>Q6JpB61r${rand_pass}';
         flush privileges;"
         expect "Enter password:" {send "9tN6GFGK60Jk8BNkBJM611GwA66uDFeG\r"}
         expect eof
 EOF
 done

#!/bin/bash
ip=192.168.3.67
mypassword=admin
mycommand=ls
# 向远程服务器请求打开一个telnet会话，并等待服务器询问用户名
expect << EOF
    spawn ssh $ip "touch expect"
    expect "password:" {send "$mypassword\r"} {send "exit\r"}     #这种有可能出现延迟
    
    spawn ssh $ip 
    expect "password:"     
      send "$mypassword\r"
    expect "#" #{ls"\r"}
      send "$mycommand\r"
      send "exit\r"
    expect eof
EOF

 
 #!/bin/bash
 file="/tmp/pack1.txt"
 while read -r pack
 do apt -y remove $pack
 done<"$file"             # 重定向stdin到文件$Filename
 		  
 for i in "1 2"; do echo ${i}; echo ok; done		  
 
 1 2 == {1,2} == {1..2}#不支持变量
 
 
 基本教程：
 shell是指在Linux内核和用户之间的解释器程序，负责向内核翻译及传达用户/程序指令   cat /etc/shells
 
 bash特性：快捷键、tab补齐、命令历史、别名、标准输入输出、重定向、管道     (C+r)
 
 shell脚本:提前写好可执行语句，特定时候完成特定任务，顺序，批量处理，解释型程序
 
 查看变量：$变量名/${变量名}    失效unset
 
 变量类型：环境变量(大写)env/set  /etc/profile // ~/.bash_profile    位置变量$1..$n    预定义变量$0 $$ $? $# $*("$1 $2 $3 $4") $@( "$1" "$2" "$3" "$4" )     自定义变量
 shell变量的值默认视为文本，当进行数学运算，自动转换称整数
 
 ""  ''   ``==$()     ${数组/截取}
 
 read [-p提示语] 变量             stty -echo：
 
 local     export [-n取消]  
 eval即对结果多执行一遍（主要用在对参数的特殊处理上面的，例如转义和变量转变）
 #例1
 #name=woodie
 #cmd="echo Helllo $name\! "
 #echo $cmd && eval $cmd  
 #例2
 #aabbcc=alibaba a=aa b=bb c=cc  alibaba="hello world"
 #eval echo \$\$$a$b$c   &&   echo \\$\$$a$b$c   &&   eval echo \\$\$$a$b$c   &&   eval eval echo \\$\$$a$b$c
 
 计算：1.$[算式]或$((算式)) --- 值引用变量可省略$，$[i+=1]/$[i++]自增    2. let i++;echo $i 自增   3.expr 算式(\*) 运算符两边需要空格，支持变量    
      小数：echo "scale=4;$a*56.56;5/3" |bc  --运算符也可换成比较符
 	 
	 
 test 选项 参数 == [ 选项 参数 ]      查看帮助：help test
 
 测试的标志	代表意义
1. 关於某个档名的『文件类型』判断，如 test -e filename 表示存在否	
	-e	该『档名』是否存在？(常用)
	-f	该『档名』是否存在且为文件(file)？(常用)
	-d	该『档名』是否存在且为目录(directory)？(常用)
	-b	该『档名』是否存在且为一个 block device 装置？
	-c	该『档名』是否存在且为一个 character device 装置？
	-S	该『档名』是否存在且为一个 Socket 文件？
	-p	该『档名』是否存在且为一个 FIFO (pipe) 文件？
	-L	该『档名』是否存在且为一个连结档？
2. 关於文件的权限侦测，如 test -r filename 表示可读否 (但 root 权限常有例外)	
	-r	侦测该档名是否存在且具有『可读』的权限？
	-w	侦测该档名是否存在且具有『可写』的权限？
	-x	侦测该档名是否存在且具有『可运行』的权限？
	-u	侦测该档名是否存在且具有『SUID』的属性？
	-g	侦测该档名是否存在且具有『SGID』的属性？
	-k	侦测该档名是否存在且具有『Sticky bit』的属性？
	-s	侦测该档名是否存在且为『非空白文件』？
3. 两个文件之间的比较，如： test file1 -nt file2	
	-nt	(newer than)判断 file1 是否比 file2 新
	-ot	(older than)判断 file1 是否比 file2 旧
	-ef	判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上。 主要意义在判定，两个文件是否均指向同一个 inode 哩！
4. 关於两个整数之间的判定，例如 test n1 -eq n2	
	-eq	两数值相等 (equal)
	-ne	两数值不等 (not equal)
	-gt	n1 大於 n2 (greater than)
	-lt	n1 小於 n2 (less than)
	-ge	n1 大於等於 n2 (greater than or equal)
	-le	n1 小於等於 n2 (less than or equal)
5. 判定字串的数据	
	test -z string	判定字串是否为 0 ？若 string 为空字串，则为 true
	test -n string	判定字串是否非为 0 ？若 string 为空字串，则为 false。注： -n 亦可省略
	test str1 = str2	判定 str1 是否等於 str2 ，若相等，则回传 true
	test str1 != str2	判定 str1 是否不等於 str2 ，若相等，则回传 false
	==  !=
6. 多重条件判定，例如： test -r filename -a -x filename	（[ "$yn" == "Y" -o "$yn" == "y" ] && echo "OK）#-o在[]里面，&&和||在[]外面									
	-a	(and)两状况同时成立！例如 test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true。
	-o	(or)两状况任何一个成立！例如 test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true。
	!	反相状态，如 test ! -x file ，当 file 不具有 x 时，回传 true
	&&  ||

 
 if [ ]; then CMD; fi                 #关键字换行就不用; 不换行需要在关键词前加；   
 if [ ]; then CMD; else CMD; fi
 if [ 条件判断式一 ]; then
 	当条件判断式一成立时，可以进行的命令工作内容；
 elif [ 条件判断式二 ]; then
 	当条件判断式二成立时，可以进行的命令工作内容；
 else
 	当条件判断式一与二均不成立时，可以进行的命令工作内容；
 fi
 
 for var in val; do CMD; done         #关键字换行就不用; 不换行需要在 关键词前 加； 
 c语言风格的for循环： for ((初值;条件;步长控制))       for ((i=1;i<=${#arr[@]};i++ )); do CMD; done
 
 while 条件; do CMD; done 
 
 case $1 in 
 var1)
    CMD;;
 var2)
    CMD;;
 *)
    CMD[;;]
 esac  
 
 函数：
 1. function 函数名{
     CMD...
    }
 2.函数名() {
     CMD...
    }
 
 中断与退出：break n(默认为1，跳出当前循环(for、while、until))  continue终止本次循环，进行下一次，exit跳出脚本
 
 shift：造成参数变量号码偏移， shift 后面可以接数字，代表拿掉最前面的几个参数的意思（格式：shift n  #就当是命令执行）
 
 字符串截取：
 1.${var:起始位:长度}                    # 起始从0开始，0可省略 
 2.expr substrate "$var" 起始位 长度     # 起始从1开始
 3.echo $var | cut -b 起始位-结束位      # 起始从1开始，起始位-结束位 1可省略
 替换：
 一个：${var/old/new}  全部：${var//old/new}
 掐头(从左往右)：最短匹配：${var#*关键词}      最长匹配：${var##*关键词}        #/var/log/message
 去尾(从右往左)：最短匹配：${var%关键词*}      最长匹配：${var%%关键词*}
 ${var}	              变量，界定范围
 ${var:-word}	      如果var为空或者未设定，返回word，var不变
 ${var:=word}	      如果var为空或者未设定，返回word，且var=word
 ${var:+word}	      如果var有值，返回word，var不变
 ${var:?word}	      如果变量var为空或者未设定，返回word并退出shell，word没有值则输出：parameter null or not set，用于检测var是否被正常赋值
 ${var-word}	      如果var未设定，返回word，如果var未空或者有值，返回var
 ${var:num}	          字符串截取，返回var中第num个字符到末尾的所有字符，正从左往右，负从右往左，有空格：${var: -2}，没有空格：${var:1-3}或${var:(-2)}

bash变量配置方式			说明
${变量#关键词} 				若变量内容从左往右的数据符合『关键词』，则将符合的最短数据删除  echo ${PATH##*:}
${变量##关键词}				若变量内容从左往右的数据符合『关键词』，则将符合的最长数据删除
${变量%关键词} 				若变量内容从尾向前的数据符合『关键词』，则将符合的最短数据删除  echo ${PATH%%:*}
${变量%%关键词}				若变量内容从尾向前的数据符合『关键词』，则将符合的最长数据删除
${变量/旧字符串/新字符串} 	若变量内容符合『旧字符串』则『第一个旧字符串会被新字符串取代
${变量//旧字符串/新字符串}	若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串取代    echo ${PATH//sbin/bin}

 
 
 数组：整体赋值：数组名=(值1 值2 ...)     单个元素赋值：数组名[下标]=值  #下标从0开始
 获取：单个：${数组名[下标]}   所有：${数组名[@]}   值个数：${#数组名[@]}     多个：${数组名[@]:起始:个数}
 添加：a+=(6) 或者 a[1]=6   删除：unset a[1]  修改：覆盖
 多行合并成一行：tr '\n' ' ' 
 
 预期交互：expect 为交互式过程自动输送预先准备的文本或指令
 
 正则：基本元字符：^ $ . + ? * {n} {n,m} {n,}
       其它：[]范围内单字匹配 ()整体  |或者 \b单词边界	   
	特殊符号	代表意义
	[:alnum:]	代表英文大小写字节及数字，亦即 0-9, A-Z, a-z
	[:alpha:]	代表任何英文大小写字节，亦即 A-Z, a-z
	[:blank:]	代表空白键与 [Tab] 按键两者
	[:cntrl:]	代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等
	[:digit:]	代表数字而已，亦即 0-9
	[:graph:]	除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键
	[:lower:]	代表小写字节，亦即 a-z
	[:print:]	代表任何可以被列印出来的字节
	[:punct:]	代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...
	[:upper:]	代表大写字节，亦即 A-Z
	[:space:]	任何会产生空白的字节，包括空白键, [Tab], CR 等等
	[:xdigit:]	代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节
	元字符使用：
	元字符：
		a  						单个字符，包括汉字    
		|  						或(已匹配过的字符，就不会再匹配)
		.  						匹配除换行外的任意字符
		^  						匹配字符串的开始位置
		$  						匹配字符串的结束位置
		*  						匹配前一个字符出现0次或多次
		+  						匹配前一个字符出现1次或多次
		？ 						匹配前一个字符出现0次或1次
		{n}						匹配n次重复次数
		{m,n}       			匹配m到n次重复次数(包含mn)
		.+/.*       			匹配全部
		[字符集]    			匹配字符集中任意一个字符([_a-zA-Z0-9])
		[^字符集]   			过滤，即除字符集外的任意字符
		\d == [0-9]				匹配任意数字字符
		\D == [^0-9]			匹配任意非数字字符
		\w                      普通字符(字母数字下划线及汉字)
		\W						非普通字符
		\s						匹配任意空字符[\r\t\n\v\f ]
		\S                      匹配任意非空字符
		\A == ^                 匹配字符串的开始位置
		\Z == $                 匹配字符串的结束位置
		\b						匹配单词边界位置(普通字符和非普通字符交界认为是单词边界)
		\B						匹配非单词边界位置
		\cx						匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一
	匹配单个字符： a . \d \D \w \W \s \S [..] [^..] 	
	匹配重复：*  +  ?  {n}	 {m,n}
	匹配位置:  ^  $  \A  \Z  \b  \B
	其它： |  ()  \
		
	绝对匹配：
		正则表达式要完全匹配目标字符串内容(\d+  --- "123"(完全匹配)  "as123df"(不是))
		"^正则表达式$"    在正则表达式开始和结束位置加上^$
		
	正则表达式转义：	
	
	raw字串：原始字符串对内容不解释转义，就表达内容原本意义
		
	贪婪与非贪婪：	
		贪婪模式：正则表达式的重复匹配总是尽可能多的向后匹配更多内容
			*  +  ?  {3,5}
				re.findall(r"ab{3,5}","abbbbbb")   --->  结果：['abbbbb']
		非贪婪模式(懒惰模式)：尽可能少的匹配内容
			*?  +?  ??  {3,5}?
				re.findall(r"ab*?","abbbbbb")   --->  结果：['a']
	
	正则表达式的子组：
		可以使用()为正则表达式建立子组，子组可以看作是正则表达式内部操作的一个整体，即先匹配整体，在内部子组匹配
			子组是在正则表达式整体匹配到内容的前提下才会发挥作用，不影响正则表达式整体去匹配目标内容这一原则
		re.findall(r"(ab)*","ababab")    #()会将ab当作一个整体
	
		子组所用：
			1.作为内部整体可以改变某些元字符的行为(正则)
				re.search(r"\w+@\w+\.(com|cn)","abc@123.com").group()   ---  'abc@123.com'
				re.search(r"\w+@\w+\.(com|cn)","abc@123.cn").group()	---  'abc@123.cn'
				re.search(r"\w+@\w+\.com|cn","abc@123.com").group()		---  'abc@123.com'
				re.search(r"\w+@\w+\.com|cn","abc@123.cn").group()		---  'cn'
			2.子组在某些操作中可以单独提取出匹配内容(编程)
				re.search(r"(https|http|ftp)://\S+","https://www.baidu.com").group()   ---  'https://www.baidu.com'
				re.search(r"(https|http|ftp)://\S+","https://www.baidu.com").group(1)  ---  'https'
		子组注意事项：
			1.一个正则表达式中可以有多个子组
			2.子组一般由外到内，由左到右称之为第一组，第二组...
			3.子组不能重叠，嵌套也不宜很多
	
	
	捕获组和非捕获组
		格式：(?P<name>pattern)
			作用：可以通过组名更方便获取某组内容
				re.search(r"(?P<dog>ab)cdef",'abcdef').group('dog')
	
	对字符串："industry  industries  industr123"的匹配结果：
		(pattern)
			industr(y|ies) ---> industry  industries
		非获取匹配，不进行存储供以后使用,不会把pattern结果放到Matches的集合中
			(?:pattern) 消耗字符，下一字符匹配会从已匹配后的位置开始。
				industr(?:y|ies) ---> industry industries
			1.(?=pattern) 不消耗字符，下一字符匹配会从预查之前的位置开始。				
				industr(?=y|ies) ---> industr industr（12）
			2.(?!pattern)
				industr(?!y|ies) ---> industr（3）
			3.(?<=pattern)
				(?<=NT|2000)Windows“能匹配”2000Windows“中的”Windows“，但不能匹配”3.1Windows“中的” Windows
			4.(?<!pattern)
				(?<!NT|2000)Windows“能匹配”3.1Windows“中的”Windows“，但不能匹配”2000Windows“中的” Windows“	
	向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第 num 个用括号围起来的子表达式（subexpression）匹配,从 1 开始的正整数，其上限可能是 99。例如：”(.)\1“匹配两个连续的相同字符
		
		
 
 #sed流式编辑器：
 #1. 前置命令 | sed [选项] '条件+指令'
 #2. sed [选项] '条件+指令'  文件.. ..
 #选项：-n屏蔽默认输出   -i实际修改   -r支持正则但应作为首个选项
 #条件：行号或者/正则/                                                #2,4p输出234行  2p;4p输出24行  4,+10p输出4及后面10行  $=输出文件的行数 
 #动作指令：p打印  d删除   s替换                                      # ！取反  s/old/new/ 3g  替换第一个，第三个，全部      $d删除文件最后一行
 #          i行前插入  a行后插入 c替换
		   
SED：sed -h
	'2,5d'   '2a drink tea'  '2,5c No 2-5 number'   's/#.*$//g'  '$a # This is a test' regular_express.txt  '2,5!p'  '2!p;6!p'     '/hello/aworld\nwestos'   '/^#/d' 
	s/my/**&**/  #符号&代表查找串。my将被替换为**my**
-n：使用安静(silent)模式。在一般 sed 的用法中，只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
-e：直接在命令列模式上进行 sed 的动作编辑；
-f：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的sed 动作；
-r：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
-i：直接修改读取的文件内容，而不是由萤幕输出。


动作说明：  [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
		是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』
function 
a   ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c   ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d   ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i   ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p   ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s   ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配
sed -n '/8002/p'  test     					 #过滤8002行并整行输出
sed -nr 's/80/nishizhu/p'  /etc/services	 #将替换结果显示出来
sed -n '/\b80/{/tcp[ ]/p}'  /etc/services    #双条件 \b表示边界
sed 's/^/添加的头部&/g;s/$/&添加的尾部/g' /etc/services    #符号&代表查找串，可以先使用p输出，同时执行两个替换规则
sed -n 's/asd$/123/gp' test     #同一行多个匹配的情况下只匹配并替换asd结尾的哪一个
 
 #awk编程语言/数据处理引擎
 #1.前置命令 | awk [选项] '[条件]{指令}'
 #2.awk [选项] '[条件]{指令}' 文件.. ..
 #选项：-F[] 指定分隔符
 #内置变量：FS=":" 与-F一样    $n第n个字段    $0整行文本内容   NF最后一个字段,列数   NR行数
 #过滤时机: BEGIN{} {} END{}          #每个段都可以添加条件，每个段都一样一个{}  即awk -F[:] 'BEGIN{} {} END{}' filename
 #过滤时机：awk [选项] 'BEGIN{指令} {指令} END{指令} ' 文件
 #条件：/正则/  $7!~/bash$/ 
 #      数值/字符串比较 > < == != >= <=
 #      逻辑比较&&  ||   
 #	  运算符+-*/%  ++ -- += -= *= /=
 #流程控制：单分支：if(条件){编辑指令}    双分支：if(条件){编辑指令1}else{编辑指令2}   
 #          多分支(else连接多个if条件)：if(条件){编辑指令1}else if(条件){编辑指令}
 #  awk -F[:] 'BEGIN{i=0;j=0}{if($3>=500){i++}else{j++}}END{print i,j}' /etc/passwd 
 #  awk -F: 'BEGIN{i=0;j=0;k=0} {if($3<500){i++} else if($3>=500&&$3<=1000){j++} else{k++}} END{print i,j,k}' /etc/passwd   
 #  ##“else if”这个是必须有空格的  最后的else是不需要条件    BEGIN多个初始值用;分开     END{print }用,分开
 #  
 #  awk  '{ip[$1]++} END{for(i in ip) {print ip[i],i}}' ip.txt | sort -nr               #{print ip[i],i}  逗号表示空一格
 #  netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
   
AWK:
	awk匹配模式有两种: 
		1. /正则/  
		2. 关系运算匹配  > < <= >= == != ~ !~    #注意，这是不用//
			'$3<50'  
			'$7!="/bin/bash"'   
			'$3 ~ /[0-9]{3,}/'  
			'$1=="ftp" || $1=="mail"{print $0}'
		3.行范围匹配	
	awk '{ip[$1]++}END{for(i in ip){print i,ip[i]}}' access.log-20190801 | column -t								 #统计ip	
	awk -F[:] 'BEGIN{i=0;j=0} {if($3<500){i++}else if($3>=500&&$3<1000){j++} else{k++}} END{print i,j,k}' passwd     #自定义变量：i=0;j=0,这是有逻辑的(将其中一个500改成100)
	awk 'BEGIN {max = 0} {if ($1>max) max=$1 fi} END {print "Max=", max}' data  #求最大值  最值：awk '{if($1>max){max=$1}else if($1<3){min=$1}}END{print "MAX =",max"\n""MIN =",min}' data
	awk 'BEGIN{sum=0}/^$/{++sum}END{print sum}' /etc/services                        #统计空行
	awk 'BEGIN{printf "%-20s%-20s%-20s%-20s%-20s%-20s\n","Name","Chinese","English","Math","Physical","Average"}{sum=$2+$3+$4+$5;avg=sum/4}{printf "%-20s%-20d%-20d%-20d%-20d%-0.2f\n",$1,$2,$3,$4,$5,avg}' student.txt #统计平均值,逗号表示字符串分隔符，分号表示命令分隔符
	awk占位符%[modifier]control-letter  -减号是左对齐,+加号是右对齐,#显示8进制在前面加0,显示16进制在前面加0x 
三元运算：	
	awk -F: '{usertype=$3<500?"系统用户":"普通用户" ; print $1,usertype}' passwd   #等同于awk -F: '{usertype=$3<500?"系统用户":"普通用户"}{ print $1,usertype}' passwd
	awk -F: '{uid=$3>500?a++:b++}END{print "普通用户总数:" a "\n" "系统用户总数 :",b}' passwd
	awk 'i=!i' test（打印奇数行）  /   awk '{i=!i;print i}' test
	 
	c	将一个数作为ASCII字符显示
	d	显示一个整数值
	i	显示一个整数值（和d一样）
	e	用科学计数法显示一个数
	f	显示一个浮点值
	g	用科学计数法或浮点数显示（选择一个较短的格式）
	o	显示一个八进制值
	s	显示一个文本字符串
	x	显示一个十六进制值
	X	显示一个十六进制值，但用大写字母A～F
	
	内置变量：
		$0                    打印行所有信息
		$1~$n                    打印行的第1到n个字段信息
		NF Number Field                处理行的字段个数
		NR Number Row                处理行的行号
		FNR File Number Row            多文件处理时，每个文件单独记录行号
		FS Field Separator            字段分隔符，不指定时默认以空格或tab键分割,指定\n被当作空格
		RS Row Separator            行分隔符，不指定时以回车换行分割,指定\n被当作空格
		OFS Output Filed Separator        输出字段分隔符
		ORS Output Row Separator        输出行分隔符
		FILENAME                处理文件的文件名
		ARGC                    命令行参数个数
		ARGV                    命令行参数数组	
awk [-v FS="#" -v OFS='---' -v RS=" " -v ORS="++"] '{print $1 $2}/{print FILENAME,$1,$2}'  test		
awk '{print NR/FNR/NF,$0,ARGV[0],ARGV[1],ARGV[2],ARGC}' test test1
abc=666  awk -v myvar=$abc 'BEGIN{print myvar}'	
awk [--re-interval] '/ro{1,2}t/{print $0}' passwd   #--re-interval 匹配指定次数,但自己试的时候不用加也可以
awk '/shutdown/,/operator/{print NR,$0}' passwd			#范围性输出，输出第一个匹配/root/和/operator/之间(包括)的行
awk 'NR>=3&&NR<=6{print NR,$0}' passwd					#3-6行	
cat -n passwd|awk -F: '{print $1}{print NR}'		#对于一行，输出$1再输出$2 等同于cat -n passwd|awk -F: '{print $1;print NR}'	
awk '{sum+=$2}END{print sum}' date  // cat data|awk '{sum+=$1} END {print "Average = ", sum/NR}'  //  cat data|awk 'BEGIN {max = 0} {if ($1>max) max=$1 fi} END {print "Max=", max}'  //   
awk '($1~/[0-9]/&&$2~/[0-9]/)||($3~/[a-zA-Z]/){print $0}' awk.txt  #与或	
	内置函数
		rand，srand，int
		gsub  sub  length  index
		awk 'BEGIN{srand();print rand()}'   	 	awk 'BEGIN{srand();print int(100*rand())}'	  #随机数
		awk '{gsub("a","A");print $0}' passwd    	awk '{gsub("[a-z]","6");print $0}' passwd     #替换
		awk '{sub("[a-z]","6");print $0}' passwd	#替换	awk '{print $0,length()}' passwd	#字符串长度
		awk '{print index($0,"root")}' passwd   #root所在位置  
  
  
  

cat << EOF > /root/test.txt 或 cat > /root/test.txt <<EOF     #覆盖 PATH=\$PATH:\$HOME/bin 涉及到变量操作时是需要进行转义(原始覆盖，不转义则会变量替换才覆盖)
cat << EOF >> /root/test.txt 或  cat >> /root/test.txt <<EOF  #追加
read -n 4 >file            # 只读取4个字符到文件file
command < file1 > file2    #命令参数从file1读入，输入到file2中

shell script : fork出一个子进程，再执行命令   -- bash /root/sh.sh ---   bash(88820)───bash(88932)───sleep(88933)
source : 在当前bash环境下执行命令			  --   source  sh.sh  ---   bash(88485)───sleep(88594)
exec：将当前bash替换成命令执行，执行完成退出  --    exec ./sh.sh  ---   sh.sh(88701)───sleep(88733)    #exec在对文件描述符进行操作的时候，也只有在这时，exec不会覆盖你当前的 shell 环境
exec命令：
    n>&-               #关闭输出文件描述符n.
    n<&-               #关闭输入文件描述符n.
      exec 1&-           # 关闭 FD1  默认对文件描述符1进行操作
      exec 5>&-          # 关闭 FD5
  exec 4<&1          # 备份当前stdout至FD4
  exec 1>1.txt       # stdout重定向至1.txt
  exec 1<&4          # 恢复stdout
  exec 4>&-          # 关闭 FD4
    [j]<>filename     # 为了读写"filename", 把文件"filename"打开, 并且将文件描述符"j"分配给它.
  exec <filename命令会将stdin重定向到文件中. 从这句开始, 所有的stdin就都来自于这个文件了
  exec >filename命令将会把stdout重定向到一个指定的文件中. 这样所有命令的输出就都会发送到那个指定的文件
	
    exec <file	file中的内容作为标准输入（替代STDIN）
    exec >file	将标准输出写入file（替代STDOUT）
    exec 3<file	将file读入到文件描述符3中（此时，创建了文件描述符3）
    sort <&3	将文件描述符3作为临时输入，用于sort排序
    exec 4>file	将写入文件描述符4中的内容写入file中（此时，创建了文件描述符4）
    ls >&4	Ls将不会有显示，直接写入文件描述符4中了，即上面的file中
    exec 5<&4	创建文件描述符4的拷贝文件描述符5
    exec &- 关闭标准输出
    exec 3<&-	关闭文件描述符3


三目运算：
[ -z "$a" ] && echo yes || echo no    #使用-z或-n判断字符串长度时，变量要加双引号。或者是用[[]]
     #第一种：当判断为fasle时候，会执行第一个||开始加上后面所有的&&后面的语句(无论何种情况，只会执行第一个||)   第二种：当判断结果为true时候，会执行所有的&&之后的语句
echo $((1>0?1:2))      #输出指定数字
echo $((1<0))          #输出0/1
echo "1.2 < 2" |bc     #支持浮点数echo "1.2 != 2.2" |bc




expr length "string"   #获取字符串长度
expr index "string" str   #获取字符在字符串中出现的位置

( )	     用途1：在运算中，先计算小括号里面的内容   用途2：数组    用途3：匹配分组
(( ))	 用途1：表达式，不支持-eq这类的运算符。不支持-a和-o，支持<=、>=、<、>这类比较符和&&、||      用途2：C语言风格的for(())表达式
$(( ))	 用途1：简单算数运算   用途2：支持三目运算符 $(( 表达式?数字:数字 ))
$( )	 执行Shell命令，与反撇号等效，但移植性不如``
` `	     条件表达式，里面不支持布尔运算符(! -a和-o)，不支持<=和>=比较符，支持-eq、<、>这类比较符。支持=~模式匹配，也可以不用双引号也不会影响原意，比[]更加通用
[ ]	     条件表达式，支持布尔运算符(! -a和-o),里面不支持逻辑判断符( &&  || )
$[ ]	 简单算数运算
[[]]     支持=~操作符 [[ hello == hell? ]]  支持逻辑判断符(！ &&  || )
{ }		 对逗号（,）和点点（...）起作用，比如touch {1,2}创建1和2文件，touch {1..3}创建1、2和3文件
${ }	 用途1：引用变量  用途2：字符串处理及默认值










