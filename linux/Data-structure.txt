
数据结构和算法
定义：数据元素相互之间存在的一种或多种特定关系的集合

分类：！！
	逻辑结构：数据对象中数据元素之间的相互关系(将现实问题转化成计算机能理解的数据结构)
		集合结构：同属一个集合，此外无其他关系
		线性结构：一对一
		树形结构：传销的金字塔结构
		图形结构：多对多
	物理结构：数据的逻辑结构在计算机中的存储形式(内存是线性的)
		顺序存储：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
		链式存储：关注的是下一个号码，即号码本身存储下一个号码的位置(指针)，其它状态不约束，逻辑关系和物理关系是不一致的

算法特征：输入，输出，有穷性，确定性，可行性
要求：正确性，可读性，健壮型(容错)，时间效率高和存储量低 

算法时间复杂度：T(n)=O(f(x))需要使用多少时间
空间复杂度：S(n)=O(f(x))需要使用多少硬件资源
例子：判断某一年是不是闰年(假设是1-2020)
第一种：给一个公式，输入一个年份计算一次(消耗时间，节省空间)
第二种：将1-2020中闰年标记出来并存储在内存中(消耗空间，节省时间)

线性表：由零个或多个数据元素组成的有限序列
	1是2的直接前驱元素   2是1的直接后继元素
	
抽象数据类型：由基础数据组成的数据(可以自定义)
内存的大小和内存的分配策略/物理结构(考虑增删查改的复杂度)
集合： 确定性  互异性  无序性
线性表：增删查改

顺序存储：初始化一块定量的连续内存，适合查找和修改(代表类型:数组)
链式存储：不定量的不连续内存，适合插入和删除，需要由指针（数据+指针）
	单链表：每个节点中值包含一个指针域
		头指针(不为空)【指向头节点(存放元数据)  节点（数据+指针(后继元素的存储地址)）】 null
		存储映像/节点：指针域和数据域组成的数据元素
	静态链表(用的少)：游标 == 指针 备用链表指向空数据域游标，空数据域游标指向备用链表(首节点)
	循环链表：头指针(不为空)【指向头节点(存放元数据)  节点（数据+指针(后继元素的存储地址)）】 头节点
	双向链表：节点包含两个指针和一个数据
	
	
栈(后进先出LIFO,一个门)	:特殊的线性表，只能对表尾(一端,栈顶TOP)进行删除和增加 ，一般是使用顺序存储(元素不需要移动)

清空数据可以看作是top移到栈底
浏览器的返回按钮：浏览器维护一个栈
电脑进制转换：二进制转换十进制有栈的特性
数字算术运算：逆波兰计算器 -- 将中缀表达式转换成后缀表达式，即1+(2-3)*4+10/5(输入)  ---  123-4*+10/5+(计算机运算)

队列(先进先出FIFO,两个门):只允许一端进行插入操作，另一端进行删除操作的线性表，一般是使用链式存储(元素需要移动)			
	
迭代是循环：for while
递归：自己调用自己(效率低：入栈和出栈cpu需要保存当前环境)	
	
字符串：由零个或多个字符组成的有限序列
      匹配：
		BF：挨个顺序比对（回溯法）
		KMP: 问题由模式串决定，不是由目标决定(然后模式串按顺序找重复字符串(bbsbb/bsbsbsbs,bb/bsbs就是重复字符串(1-n)),决定一旦模式串和目标串挨个进行匹配错误后，能直接移动多少个字符进行新一轮匹配)



树：根节点(唯一)和子节点	 子树
	内存存储：
		1.下标  数据  双亲下标   				#双亲节点(1) 子节点--遍历
		2.下标  数据  双亲下标 兄弟/子节点下标  # (1)
		3.顺序存储(按元素存储)+链式存储(指向子节点)
	
	二叉树：每个节点最多又两颗子树(0-2)  区分左子树和右子树
	满二叉树：不是最底层的子节点都有两个子节点
	完全二叉树：按顺序排列
	遍历方法：
		前序遍历：根结点 ---> 左子树 ---> 右子树
		中序遍历：左子树---> 根结点 ---> 右子树	
		后序遍历：左子树 ---> 右子树 ---> 根结点
		层次遍历：只需按层次遍历即可
		
	树，深林，二叉树的转换
	树的遍历主要有先根遍历和后根遍历。
	森林的遍历前序遍历和中序遍历
	
	赫夫曼树：把两棵二叉树简化成叶子结点带权重的二叉树
	权重能优化代码。
	
图：由顶点的有穷非空集合和顶点之间变得集合组成 G(V,E) G图V点E边	  和树相比没有次序
	存储：通过扩充节点维度实现
		邻接矩阵：二维数组（点和边的关系）
		邻接表：数组 + 链表
		十字链表：邻接表和逆邻接表(有向)
		邻接多重表：
	遍历：马踏棋盘
		深度优先遍历：从一点开始，遇到都被标记的往回退，退到第一个点就结束了(递归)
		
回溯法（探索与回溯法）是一种选优搜索法，又称为试探法（试错思想），按选优条件向前搜索，以达到目标。 但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”	
贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解
哨兵sentinel ：就是用来指定一个位置的特殊元素   应用：简化判断条件/边界条件的处理

最小生成树：权重最小的树
	普利姆算法：
	克鲁斯卡尔算法：
最短路径：
    网图：两顶点经过的边上权值之和最少的路径
	非网图：两顶点之间经过的边数最少的路径
	算法：
		迪杰斯特拉算法：基于已求出的最短路径的基础上，求得更远顶点的最短路径
		弗洛伊德算法：

一个无环的有向图称为无环图DAG图	
拓扑序列：从一边指向另一边
拓扑排序：对一个有向图构造拓扑序列的过程	
	
AOE和AOV	
	
查找算法：顺序查找(无序)	
插值查找：按比例查找
斐波那契数列：黄金分割法查找
线性索引查找：稠密索引(hash索引)  分块索引   倒排索引(es)


将一个9个数据集的记录删除其中一个元素，先与最后元素互换，在删除

二叉排序树：有序的二叉树(中序遍历是从小到大排序的) 多用在内部排序，即全放在内存中的
	插入和查找不会改变现有结构，删除会改变现有结构，由前驱/后继元素替代上
平衡二叉树AVL：在二叉排序法基础上，当插入数据不平衡时根据规则旋转

红黑树放弃了追求完全平衡，追求大致平衡，平衡二叉树追求绝对平衡，条件比较苛刻，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单


多路查找树：每个节点有多个子节点 （B树/B-树是平衡多路查找树） 大部分数据存储在外存上，查找的时间复杂度与树高相关,大量数据存储中,树深度过大而造成磁盘IO读写过于频繁
B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定
	层级更少
	每次数据查询的次数都一样
	B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加
	B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可
	B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便
	B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快
B*树是B+树的变种，B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来
	
	

散列技术：记录存储位置和关键字之间建立一个确定的对应关系
散列表/hash表：采用散列技术将记录存储在一块连续的存储空间中
	不适合关键字重复和范围查找
	
算法简单+减少冲突
	直接定址法：hash值和内存顺序是线性关系
	数字分析法：取其中的代表字符串
	除留余数法  随机数
解决冲突：使用备用hash函数  公共溢出区法(两个hash表)


排序算法：
  交换排序类：
	冒泡排序（Bubble Sort）：重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们立刻交换过来(第一轮先交换出最值，第二轮交换出次最值)。 走访元素的工作是重复地进行直到没有相邻元素需要交换 O(n^2)
	快速排序：每次以一个元素为基准进行排序（大数据）
  选择排序类：
	选择排序法：和冒泡排序不一样的是，每次比较到最后才移动，即只移动一次 O(n^2)
	堆排序：完全二叉树，根节点是最值  O(n*logn)
  插入排序类：	
	直接插入排序：小数据性能好，将记录插入已经排好序的有序表中 O(n^2)
	希尔排序：分组排序 O(n*logn)
  归并排序类：	
	归并排序：分治法，将已有序的子序列合并，得到完全有序的序列O(n*logn)
	
尾递归：一个函数中所有递归形式的调用都出现在函数的末尾
	当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的，缩减栈的使用空间




	
	