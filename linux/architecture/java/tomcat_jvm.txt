 
 tomcat调试：
 jstack,jmap,jinfo,jstat,jps
 
 gc(garbage collection)：垃圾回收（内存）
 Minor GC：从年轻代空间（包括 Eden 和 Survivor(From To)区域）回收内存，一般占据堆的1/3空间，会频繁触发MinorGC进行垃圾回收。当Eden区内存不够的时候就会触发MinorGC
 Major GC：是清理老年代(标记—清除算法)。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间,耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。
 Full  GC：是清理整个堆空间—包括年轻代和老年代。
 Permsize：永久代，内存的永久保存区域，主要存放Class和Meta（元数据）的信息。默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制
 Metaspace(元空间)：Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间并不在虚拟机中，而是使用本地内存。
 JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
 
 
 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。
 线程堆(heap)栈(stack)也称线程调用堆栈，是虚拟机中所有线程的运行状态（包括锁）的一个瞬间快照,
 堆栈是一种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。一端是固定的，另一端是浮动的。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。
 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 堆是一个运行时数据区，由垃圾回收来负责。
 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要 在运行时动态分配内存，存取速度较慢。
 要点对比：指令队列，先进先出（FIFO—first in first out）。堆栈，先进后出 (FILO—First-In/Last-Out)。
 输出堆栈：Java虚拟机提供了线程转储（thread dump）的后门，通过这个后门可以把线程堆栈打印出来
 堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。
 栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。
 
 栈区主要存放编译器在需要的时候自动分配，在不需要的时候自动销毁的变量。主要是局部变量和函数的参数等，在函数调用和传参的时候，编译器为局部变量或形参开辟空间
 堆区是一个动态的存储区域，使用库函数malloc()和free()，和操作符new和delete以及一些相关变量来进行分配和回收，
 内存管理中的“堆栈”其实是分为堆(heap)和栈(stack)的，以引用变量为例，引用变量本身存储在栈中，引用变量指向的值存储在堆中。
 数据结构中的一般称“栈(stack)”，是一种后进先出的数据结构。它是一种概念，或者说是一种逻辑技术，与语言、平台无关。
 
 1.在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
 2.紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，
 3.而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向(一般是15)。
   年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
 4.经过这次GC后，Eden区和From区已经被清空。
   这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。
   不管怎样，都会保证名为To的Survivor区域是空的。
 5.Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
 
 jstat -gccause pid                                      查看gc相关信息
 jstack -l  pid  > /tmp/jvm.dump                         导出进程堆栈信息
 top -H -p pid  或 ps -mp pid -o pid,THREAD,tid,time     查出进程内占用cpu高的线程pid     
 
 
 
 
 https://www.jianshu.com/p/d8492e748c57   //   https://www.bilibili.com/video/av44880257?p=2   //  https://github.com/doocs/jvm
 
 jar包是将多个类文件变成一个压缩包
 java运行机制：
 java源代码文件*.java -- （编译器） -- java字节码文件*.class --- 类加载器 --- 内存区域/运行时数据区(方法区，堆，虚拟机栈 本地方法栈 程序计数器) --- 1.执行器-->2.本地方法接口---本地方法库
 
 
 1.类文件结构(java字节码文件*.class)：
      u1，u2，u4，u8  分别代表了1、2、4、8个字节的无符号数
      ClassFile { 
          u4 magic;  // 魔法数字，表明当前文件是.class文件，固定0xCAFEBABE(Java类文件)
          u2 minor_version; // 分别为Class文件的副版本和主版本
          u2 major_version; 
          u2 constant_pool_count; // 常量池计数
          cp_info constant_pool[constant_pool_count-1];  // 常量池内容
          u2 access_flags; // 类访问标识
          u2 this_class; // 当前类
          u2 super_class; // 父类
          u2 interfaces_count; // 实现的接口数
          u2 interfaces[interfaces_count]; // 实现接口信息
          u2 fields_count; // 字段数量
          field_info fields[fields_count]; // 包含的字段信息 
          u2 methods_count; // 方法数量
          method_info methods[methods_count]; // 包含的方法信息
          u2 attributes_count;  // 属性数量
          attribute_info attributes[attributes_count]; // 各种属性
      }
      
      类名不超过256
      class文件包括：虚拟机指令  符号表  其他辅助信息  
           数据结构：无符号数(正整数)    表*_info(表结构嵌套) 
      访问控制标志(access flags)：
      
      class文件结构---常量池(主次版本号之后就是常量池入口，代表class文件中的仓库资源)：主要存放两大类常量：
      字面量：int a=3;(=号右边的东西)
      符号引用：类和接口的全限定名(绝对路径)   字段的名称和描述符   方法的名称和描述符
      
      init：实例化初始方法
      clinit：类和接口的初始化
 
 2.java虚拟机类加载机制：加载loading---连接linking（验证verification--准备preparation---解析resolution）---初始化initialization(转换成内存地址)---使用using---卸载unloading
      双亲委任JVM类加载机制：安全，保证代码不会被篡改
 	 静态加载到内存变成动态(常量池...)
 
 
 3.java虚拟机运行时数据区：方法区，堆，虚拟机栈 本地方法栈 程序计数器
      方法区存放的数据(javap -verbose TestClass.class)：类的描述，常量池(常量，静态变量)，jit即时编译编译器,编译成机器指令 (线程共享)方法区无法满足内存分配需求时OOM
      堆heap存放的数据((new)实例化)：类的实例：对象 (线程共享)
      栈区：执行/业务逻辑(线程私有)，一个栈帧 = 调用一次函数    一个main()函数调用(可以嵌套函数) = 一个栈     随着栈帧的弹出(返回)而消失
 	    虚拟机栈： 分配基本类型和自定义对象(堆)的引用(局部变量表，操作数栈，动态连接/方法返回地址)
 		本地方法栈 ：为了native方法的调用/执行/退出    c/c++本地方法库
 		程序计数器(PC counter)：存放下一条指令的地址(cpu--->指令寄存器<-----程序计数器
 局部变量：8种类型+引用，是一个函数里面的变量           
 FILO：先进后出---栈      栈帧：先进(栈底)后进(栈顶)
 FIFO：先进先出---队列
 
 4.java垃圾回收（jdk1.7/1.8 parallel scavenge新生代+parallel old      jdk1.9  G1 ） 
   Minor GC：针对年轻代
   Major GC  fullgc针对老年代：Major GC的时候会同时执行fullgc(parallel scavenge收集器例外)
   针对方法区和堆区，栈是线程私有数据，不进行回收
   1.引用计数(好像不用了)：给对象添加一个引用计数器，每当堆这个对象进行一次引用，计数器就加1，每当引用失效的时候，引用计数器就减，当这个引用计数器等于0的时候，表示这个对象不会再被引用
   2.可达性分析：判断对象是否被引用
 强引用：有用且必须，代码中有明显的new object()这类引用，只要引用还在，垃圾回收器就不会回收它，内存不够，则会报OOM异常
 软引用：有用非必须，内存够用存在，内存不够用则会被回收
 弱引用：非必须对象，只能生存到下次垃圾收集时
 虚引用：无用对象，垃圾收集时会收到系统通知
   标记-清除算法：效率不高且碎片化(大对象找不到连续的空间报OOM)(老年代)
   复制算法：只能使用一半内存，内存利用率低
   标记整理算法：标记回收后，再整理碎片(老年代)
   分代收集算法：新生代(Eden+From+To)
 保守GC:
 非保守式的GC
 精确式GC   hotspot---> oopmap记录在安全点safepoint的时候可以回收那些数据
 stw(stop the world)：停止所有线程（老年代：内存大，且stw） 所有GC都会停止应用所有线程。
 抢先式中断：主动中断，没有执行到指定安全点的用户线程，继续执行直到safepoint
 主动式中断：当gc需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，然后让用户线程自己去检查，然后中断
   垃圾回收器参数：-XX:+Use<垃圾回收器名称>GC	
   serial(串行)收集器：单线程，新生代和老年代都会STW    适合场景：用户的桌面应用场景
   serial old:
   parnew(parallelnew)收集器：只对新生代串行收集，老年代单线程
   parnew old(并行):新生代和老年代都是用多线程
   parallel scavenge收集器:用户可以控制垃圾回收时间    适合场景：后台计算不需要太多交互
     吞吐量：用户代码执行时间/(用户代码执行时间+gc时间)
 	吞吐量99%：用户代码执行时间99%，1%GC时间
   concurrent mark sweep(CMS)收集器：初始标记(STW)扫描标记gc roots---并发标记---重新标记(STW)可达性分析---并发清理(单线程回收+用户线程)       #递归标记。特点：低停顿。使用场景：互联网站或者web服务器
      -XX:+UseConcMarkSweepGC使用CMS内存收集   -XX:+UseCMSCompactAtFullCollection 整理碎片   -XX:CMSFullGCsBeforeCompaction 执行多少fullgc进行整理   -XX:CMSInitiatingOccupancyFraction  老年代阈值到多少执行一次fullgc[(old-eden-from)/(old-新生代)*100]     
      CMS回收线程默认数量：回收线程=(cpu数量+3)/4    
   G1回收器：分代收集器(年轻代)：Eden(伊甸) survivor幸存区  Old(Tenured)  Humongous   算法：复制(年轻代)+标记-整理(老年代)    特点：空间整合     
       younggc：1.扫描gc roots 2.更新remenberset记录回收对象的数据结构 3.检测rememberset(往幸存代/老年代)  4.复制对象(往幸存代/老年代)  5.清理 
 	  oldgc ：与cms不同是并发回收的时候是多线程回收   
 jvm内存分配与回收策略： -XX:SurvivorRatio      Eden+s0+s1 = SurvivorRatio:1:1
   1.大对象直接进入老年代   -XX:PretenureSizeThreshold设置值的对象直接在老年代分配(仅parnew和serial串行gc有效)
   2.长期存活的对象将进入老年代   -XX:MaxTenuringThreshold (针对Minor GC)
   3.动态对象年龄判断：相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
   4.空间分配担保 ： 1、满足，minor gc是安全的，可以进行minor gc。
                     2、不满足，虚拟机查看HandlePromotionFailure参数：
 					 （1）为true，允许担保失败，会继续检测老年代最大可用的连续空间>历次晋升到老年代对象的平均大小(例1+2+3/3)。若大于，将尝试进行一次minor gc，若失败，则重新进行一次full gc。
 					 （2）为false，则不允许冒险，要进行full gc（对老年代进行gc）
 
 
   寄存器是中央处理器内的组成部分，运行速度快。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，寄存器有累加器(ACC)。
   java指令(255条)：基于栈的执行引擎，不依赖硬件，但运行速度慢
   原子操作:不可分割，单次操作
 5.字节码执行引擎：1.输入的是字节码文件   2.处理过程是字节码解析的过程  3.输出的是执行结果
   java=jit编译器(热点代码运行时编译成本地代码，与os绑定)+解释器(栈运行，内存映像)
   每一个栈代表一个执行方法，栈帧代表当前方法(jvm只关注栈顶，调用栈顶方法)，栈帧之间有重叠区域，共享
   压栈：将局部变量表+操作数栈得到的返回值压入调用者的栈帧
   多态：静态(在类加载阶段(解析)或者第一次使用/编译的时候就转化为直接引用，将符号引用变成直接引用)+动态   
   栈帧：1.局部变量表(a=1,b=2,只能存放32位slot)
         2.操作数栈(指令add:a+b) (Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈)       
         3.动态连接：在每一次运行期间转化为直接引用
         4.方法返回地址：1.方法退出后恢复上层的局部变量表和操作数栈  2.压栈  3.调整pc计数器的值以指向方法调用指令后面的一条指令(方法退出：有给上层调用者产生返回值/程序异常且没处理方案，实际上就是退出当前栈帧)
         5.额外的附加信息
 
 方法调用(确定方法版本)---解析---分派(静态分派/动态分派)
 动态连接：每个栈帧都保存了一个可以指向当前方法所在类的运行时常量池， 目的是当方法中需要调用其它方法的时候能够从运行时常量池中找到对应的符号引用, 然后将符号引用转换为直接引用然后就能直接调用对应的方法这就是动态链接，不是所有的方法调用都需要进行动态链接的
 静态解析：有一部分的符号引用会在类加载的解析阶段将符号引用转换为直接引用
 实际类型：只有在运行期间new Man()这个动作发生了后才知道它的具体类型
 分派：确定调用方法的过程，在运行期间，或者静态解析的时候，确定调用方法的时候方法就可能存在重载，重写等情况这里的分派将揭开"重载"和"重写"的实现原理以及他们的选用规则
 解析和分派不是分开进行的而是相互协作的。
 非虚方法：解析/编译阶段就唯一确定版本，静态方法/私有方法/实例构造器/父类方法/final方法
 虚方法：
 虚方法表（vtable）：代替元地址(内存地址)查找，类加载阶段初始化(记录方法实际入口)，在invokeinterface执行时也会用到接口方法表itable，提高性能，虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址  
 内存地址:头地址,偏移量
 函数/方法调用=版本+执行
 
 指令	         说明
 invokeinterface	用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。（Invoke interface method）
 invokevirtual	指令用于调用对象的实例方法，根据对象的实际类型进行分派（Invoke instance method; dispatch based on class）
 invokestatic	（调用静态方法）用以调用类方法（Invoke a class (static) method ）
 invokespecial	（调用实列构造器<init>私有方法(无法继承)，父类方法）指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。（Invoke instance method; special handling for superclass, private, and instance initialization method invocations ）
 invokedynamic	JDK1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在JVM内部，而invokedynamic则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。(Invoke dynamic method)
 
 javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。
 6.调优命令
 jps  -v/-m      #JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
 jstat                     #JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
       MC(1.8)/PC(1.7)   方法区空间大小 #metaspace 元数据空间//系统内存
 	  MU(1.8)/PU(1.7)   方法区使用空间大小
   jstat -options  选项：-gc时间及次数  -gccause垃圾回收原因	  
 jinfo                     #JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数
 jhat                      #JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。
 jmap                      #JVM Memory Map命令用于生成heap dump文件。
 jstack                    #用于生成java虚拟机当前时刻的线程快照。
 jmc                       #监视和管理 Java 应用程序，不会导致相关工具类的大幅度性能开销，
 jconsole                  #Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控。
 jvisualvm                 #jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
 
 
 通常64位JVM消耗的内存会比32位的大1.5倍，起到节约内存占用的新参数
 64bitJVM从1.6开始支持压缩指针:-XX:+UseCompressdOops    oop=ordinary object pointer 普通对象指针
 
 xmx最大堆空间=xms最小堆空间=xmn年轻代空间(+old)   xss最大线空间/函数调用深度
 永生代：保存虚拟机自己的静态数据，如类和方法
 
 非堆内存：jvm无法处理
 堆外内存  文件句柄 socket句柄  数据库连接
 
 JVM调优原则：降低Full Gc频次
              确保大对数对象“朝生夕死”
 			 提高大对象进入老年代的门槛(-XX:MaxTenuringThreshold)
                                                                        
 Allocation Failure：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。
 
 -server -Xms1200m -Xmx1200m -Xmn500m -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=8 -XX:CMSInitiatingOccupancyFraction=70 -XX+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5 -XX:+HeapDumpOnOutOfMemoryError 
 
 
 