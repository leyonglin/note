
变量是关联一个对象的标识符
	赋值：变量名 = 字面值(=是赋值运算符，先运算右边得出的值赋值给变量);
	
数据类型: 作用：不同数据类型占用空间大小不同,指导jvm在运行程序时开辟多大的内存空间
    基本数据类型：存储空间中变量保存的是变量字面值
    引用数据类型：存储空间中变量保存的是内存地址
	#常量：全大写。   作用是让使用者知道如何操作(例如：COLOR=6 COLOR与6是完全等价的(计算机存储的是数字)，但是对于开发人员来说，明显COLOR更友好)
	
JAVA使用unicode编码，所以标识符可以写中文,char数据类型可以赋值一个汉字

&(逻辑与,任何情况两边算子都执行) | ! ^(逻辑异或，算子不一样为true) 
&&(短路与,第一个算子为false时，第二个算子不执行) ||(短路或,第一个算子为true，会发生短路或)
and -a & &&

 
 #########################################################################################################


 ！！！
 编译阶段：检查语法不运算并生成class文件
  java源文件*.java通过编译生成字节码文件*class
  一个源文件可编译生成多个字节码文件(每个class文件是一个类)
  编译器工具：javac *.java
 #byte b = 5;b = b + 1 编译报错，编译期间不运算，也就不知道b+1有没有超过范围。
 #byte b = 6 或b = 5 + 1 或 b = 5;b = (byte)(b + 1) 或 b += 1 编译成功，能识别
  
 运行阶段：
  app.class 通过java虚拟机的 类加载子系统classloader 加载到内存，有特定的内存/数据结构。
 		   通过java虚拟机的执行引擎读取程序计数器进行代码(将代码解释成二进制数据给操作系统执行与底层硬件交互)有序执行   
  运行命令：java 类名 (启动jvm并通过classloader将硬盘上的字节码文件加载到jvm上并执行该类中的主方法入口，进行解释成二进制数据)
 		   classpath：字节码文件查找路径
 
 class文件运行在jvm上 
 jdk：java开发环境，包含jre
 jre：java运行时环境，包含jvm
 jvm：程序，加载字节码文件并运行代码
 java虚拟机jvm通过jdk安装可得，jvm屏蔽了低层操作系统的差异
 
 垃圾回收器(自动垃圾回收机制，gc机制)：针对堆内存，回收没有"引用"的对象
 
 
 
 #########################################################################################################
 
 注释：
 	单行注释：//
 	多行注释：/* */
 	javadoc注释：      #能被javadoc解析生成帮助文档
 		/**
 		* javadoc注释
 		*/
 
 
 #########################################################################################################
 
 变量：
 
 标识符：自定义命名的(editplus:黑色)
 命名规则：字母数字下划线和美元符号，区分大小写，不能数字开头和使用关键字
 规范：
 	类名，接口名：首字母大写，单词首字母大写(editplus:jdk自带的为红色)
 	变量名，方法名：首字母小写，单词首字母大写
 	常量名：全大写
 
 关键字：全小写(editplus:蓝色)
 	
 字面值：数据，变量赋值的一部分，类似常量(true , 10 , 3.14) 整数型/浮点型/字符串字面值
 
 ！！
 变量是关联一个对象的标识符
 	是内存中一块空间：包含名称，数据类型和字面值(数据)，是内存中存储数据的最基本的单元
 	需先声明再赋值(初始化)才会真正开辟内存空间，进而访问
 声明：同一作用域中，相同变量名只能声明一次(声明代表开辟空间)
 	数据类型 变量名... ;
 赋值：赋值后才能访问
 	变量名 = 字面值(=是赋值运算符，先运算右边得出的值赋值给变量);
 
 变量作用域：变量有效范围，即在{范围内}
 	分类：局部变量(方法体内)  成员变量(类体之内)
 		成员变量没有主动赋值，系统会默认赋值
 		byte,short,int,long      0
 		float,double             0
 		boolean                  false
 		char                     \u0000
 		引用数据类型             null
 
 
 成员变量(静态变量，修饰符有static)可以被类内方法访问，存储在方法区中
 实例变量：
 成员变量(在类中定义，修饰符没有static)之实例变量在堆内存的java对象内部存储(需创建对象访问)
 局部变量在栈内存中存储，
 实例变量是一个对象一份		
 		
 #########################################################################################################

 数据类型
 
 ！！
 数据类型:
 	作用：不同数据类型占用空间大小不同,指导jvm在运行程序时开辟多大的内存空间
 基本数据类型：存储空间中变量保存的是变量字面值
 	四大类八小种：
 	整数类型:
 		byte : 占用1个字节 （第一位是符号位，范围为-128~127）
 		short: 占用2个字节
 		int	 : 占用4个字节 （默认）
 		long : 占用8个字节	（L）
 	小数类型(浮点类型)
 		float: 占用4个字节	（F）
 		double: 占用8个字节 （默认）
 	字符类型:
 		char: 占用2个字节''  (需要借助字符对照表进行加密解密,不然会产生乱码)
 	布尔类型:
 		boolean: 占用1个字节
 ！！		
 引用数据类型：存储空间中变量保存的是内存地址
 	//是一种数据类型，和基本类型一样定义变量。引用本质是局部变量，但保存的是对象的内存地址
 	//Sring s [= new student()];  s(变量)称为引用，保存(对象的)内存地址
 	//程序员只能通过引用去访问堆内存当中的对象内部的实例变量。访问：引用.变量名  修改: 引用.变量名 = 值
 	//多层引用(适用于对象之间具有关联关系)：访问：引用.引用...变量名  等价与   "(引用数据类型)类名 引用 = new 类名()"
 	类（class）--> 字符串(Sring)""
 	接口（interface）
 	数组（array）
 	
 
 
 二进制：0b
 八进制：0/0o
 十六进制：0x  (0~9 a~f)
 十六进制unicode：\u4e2d
 
 ！！
 # 456整数型字面值被当作int类型 占用4个字节
 # x变量在声明的时候是long类型，占用8个字节
 # int类型的字面值456赋值给long类型的变量x(=是运算符，先运算右边得出的值赋值给变量)，存在类型转换
 # int类型转换成long类型，小容量可以自动转换成大容量，称为自动类型转换机制
 long x = 456;
 
 # 大容量转换成小容量，需要添加强制编译转换符进行强制类型转换，但运行过程可能会精度造成损失
 #int y = x;  #错的
 int y = (int)x;
 
 #int类型存不下2147483648，默认会编译错误(=是运算符，先运算右边得出的值赋值给变量)
 #所以需要在数后面加上L，则字面值一开始就会被当成long类型
 long z = 2147483648L;
 
 转义字符：反斜杠 \
 
 基本数据类型之间相互转换规则
 	1.除布尔类型外七种类型能相互转换
 	2.容量从小到大排序,小容量向大容量转换称为自动类型转换
 		byte < short < int < long < float < double
 		char和short可表示种类数量相同，但char可以取更大正整数
 	3.大转小称为强制转换需加强制转换符
 	4.不超出范围，int(默认)类型能直接赋值byte,short,char
 	5.byte,short,char混合运算，先转换成int类型再进行运算
 	6.多种数据类型混合运算，先转换成容量最大的类型再进行转换
 
 #########################################################################################################
 
 编码：
 
 字符编码：人为干预，定义了一种文字与二进制之间对照关系。
 	ascii：1个字节(48-0 65-A 97-a)
 	简体中文：GBK
 	繁体：big5
 	unicode编码：包含所有文字(\u4e2d\u56fd)
 	多种实现方式：UTF-8   UTF-16  UTF-32
 JAVA使用unicode编码，所以标识符可以写中文,char数据类型可以赋值一个汉字
 
 
 #########################################################################################################
 
 运算符：
 
 单目/二元/三目：运算符两边的算子个数
 算术运算符：+ 加法  - 减法  * 乘法  / 除法  ％取余  ++自增 --自减(在与赋值运算符结合时候，变量在前在后有区别)
 关系运算符：== != >  <  >= <= 										#运算结果是布尔类型
 ！！
 逻辑运算符：两边的算子是布尔类型，运算结果也是布尔类型
 	&(逻辑与,任何情况两边算子都执行) | ! ^(逻辑异或，算子不一样为true) 
 	&&(短路与,第一个算子为false时，第二个算子不执行) ||(短路或,第一个算子为true，会发生短路或)
 
 赋值运算符：先运算等号右边的表达式，再赋值给左边的变量,运算不改变数据类型
 	= += -= *= /= ％= (byte b = 5;b+=3 等同于byte b = 5;b=(byte)(b + 3))
 连接运算符+：两个有一个算子是字符串，则是连接符，两个都是数值类型，则是算术运算符	
 条件/三元/三目运算符：	
 	布尔表达式 ? 表达式1 : 表达式2
 位运算符：直接操作二进制，能提高效率
 
 
 
 #########################################################################################################
 
 方法/函数：
    为了完成某个功能的代码块，能提高代码的复用率，只有调用才会执行
    定义在方法体外，类体中，类体(没有顺序)中可以定义多个方法，方法体内不能定义方法，遵循自上而下的内容
 
 定义：普通方法
 //修饰符：public static   
 //返回值类型：基本类型和引用类型和void  #返回值为字面值
 //形式参数列表：参数类型 参数名(定义局部变量)，可有0-n个，用,隔开,形参类型很重要
 //形参和实参类型(自动类型转换)和个数要相同
 修饰符 返回值类型 方法名(形式参数列表){
     java语句;
     ...
     return 返回值;   //执行了该return方法就结束了,方法中不能存在100%不会被执行的代码，不然编译不通过(无法访问的语句)
 	                 //有返回值的方法有一条return需要保证100%会被执行到，不然编译不通过(缺少返回语句)
 					 //"return;" 该语句出现在返回值为void的方法中主要是终止方法的执行
 }
 
 调用：类名.方法名(实参,实参,...)   #方法可调用其它方法
 
 
 定义：构造方法
 修饰符 方法名(形式参数列表){    //方法名与类名相同
 	构造方法体;}
 调用：new 类名(实参列表)    //返回堆内存的地址
 作用：创建和初始化实例化对象的内存空间
 
 有static调用:类名.方法名(实参);
 实例方法：
 没有static调用:引用.方法名(实参);
 没有static和数据类型的就是初始化对象,调用：new 构造方法();
 
 
 #############################################################
 
 
 方法重载Overloading： 
     重载的方法都在 同一个类 中，只与方法名和参数有关
 	方法名相同，实参不同(类型/数量/顺序...)，调用具体方法不同
 	功能相似(实参类型不同，调用方法不同)
 
 #############################################################	
 	
 方法重写/覆盖Override：	父类的方法无法满足子类的需求，子类将进行方法重写
 	发生在具有 继承的父子类 之间
 	返回值类型相同，方法名和形参列表相同(可以从父类直接复制粘贴)
 	方法权限只能相同或更高，即public是通用的
 	
 	
 #############################################################
 
 方法递归：方法中调用自己
 	必须有停止条件
 	//java语句：return n + add(n-1); 
 	报错：StackOverflowError(方法调用层次太深，内存不够新建栈帧)
 	//其它报错：OutOfMemoryError（线程太多，内存不够新建线程）
 	
 	
 	
 #############################################################
 
 ! ! !
 内存：（内存分析：(变量)存储的是字面值还是内存地址）
 常见数据结构：数组，队列(先进先出FIFO,两个门)，栈(后进先出LIFO,一个门)，列表，二叉树，哈希表，数列表
 方法执行过程中，在jvm的那种是如何分配如何变化的。
 方法只定义不调用，是不会执行和分配内存空间的，调用才会动态分配内存空间
     相关内存：方法区内存，堆内存，栈内存
 栈：stack，是一种数据结构
   栈帧指向栈顶元素，是活跃的  栈底元素
   压栈/入栈/push(方法调用)    弹栈/出栈/pop(方法运行结束)
   
 ! !
 方法区内存：加载代码片段(class文件)到方法区中的，可重复被调用(分配空间)，（static：类加载是执行切只执行一次）
 栈内存：方法被调用时(方法运行时)是在栈内存中分配的独立的内存空间，包括局部变量(方法内变量)
 堆内存：new运算符的作用是创建对象，在jvm堆内存当中开辟新的内存空间，实例变量存储在java对象内部，因此只能通过对象访问，包含没有static定义的成员变量
 
 #########################################################################################################
 
 
 面向过程：具体过程，步骤与步骤之间有因果关系(集显)
 面向对象：封装继承多态 ，关注独立对象的功能(独显)
 生命周期：面向对象的分析OOA  面向对象的设计OOD  面向对象的编程OOP
 
 封装: 1.提高安全性  2.简单操作入口 3.封装之后才会形成真正的"对象"，真正的"独立体" ，方便重复使用  
   步骤：
 	1.将每个属性私有化private
 	2.对每个值属性提供两种对外的公共方法访问
   代码：
 	private int age;
 	public void setAge(int age){	//代码可以添加业务逻辑进行控制
 	  this.age = age;}
 	public int getAge(){
       return age;}
   注意：setter 和 getter方法没有static关键字
 
 	
 继承: 只支持单继承，有了方法的覆盖和多态机制
 术语
   父类/基类/超类/superclass
   子类/派生类/subclass
 语法：
 	class 父类 {
 	}
 	[修饰符列表] class 子类 extends 父类 {
 	    public 子类名(形参列表) { 
         super(myName, myid); 
 		} 
 	}
 
 ！！	
 多态：编译和运行阶段绑定状态不同(同一个接口，使用不同的实例而执行不同操作)
 	前提：继承关系（Bird和Cat都继承自Animal,但Bird和Cat没有继承关系）
 	    向上转型upcasting : 通过子类对象(小范围)实例化父类对象(大范围),属于自动转换
 			父类引用指向子类对象：Animal a = new Cat();
 				静态绑定：编译期会将a当成Animal引用数据类型(因此不能使用Animal没有的方法,编译不通过)
 				动态绑定：运行期执行的方法是实际引用对象(cat)的方法
 	    向下转型downcasting : 通过父类对象(大范围)实例化子类对象(小范围),属于强制转换，出现在要调用子类特有的方法
 			Animal a = new Cat();
 			Cat c = (Cat)a;   //强制类型转换
 			// Bird c = (Bird)a; 编译能通过，因为Animal和Bird有继承关系，但运行期会报错ClassCastException
 			// 使用instanceof来避免出错此类错误即能否向下转型（if判断）"引用 instanceof 引用数据类型"
 降低程序的耦合度(中间件)，提高程序的拓展力，面对抽象编程
 例子：程序入口类(实例化对象及调用) -- 人类 -- 宠物类 -- 具体宠物类
 	类(宠物)是一个中间抽象类，连接人和具体宠物，让具体宠物继承自宠物类，宠物类抽象出方法让具体宠物类进行方法覆盖，人类参数为宠物类，可以利用多态，使传入参数不同，调用不同方法
 	当出现新需求时，只需要让新需求继承自中间抽象类，这样的话，就可以"添加具体宠物类和新增程序入口类方法"，"不用修改"人类的传入参数
 
 
 类：抽象的，具有共同特征的模板       
 	属性：描述对象的状态信息(描述词) 通常是以变量形式定义的,创建对象后可实例化为实例变量
 	方法：描述对象的动作信息(动词)
 	定义：修饰符 class 类名{ 成员变量+方法 }
 对象/实例：依据类实例化/创建出来，有个性特征的（new运算符在堆内存中开辟的内存空间称为对象）
 	//new运算符的作用是创建对象，在jvm堆内存当中开辟新的内存空间
 	创建：new 类名/构造方法名(实参列表)
 
 定义：构造方法
 修饰符 方法名(形式参数列表){    //方法名与类名相同
 	构造方法体;}
 调用：new 类名(实参列表)    //返回堆内存的地址
 作用：创建和初始化实例化对象的内存空间
 支持重载机制
 	
 访问对象只能通过"引用"方式访问，对象之间的关联关系可以使用"引用"(定义类时通过类属性定义变量(引用)，创建实例时赋值关联对象内存地址)
 局部变量在栈内存中存储，成员变量(在类中定义)中的实例变量在堆内存的java对象内部存储
 实例变量是一个对象一份
 
 #########################################################################################################
 
 
 关键字：
 this：是一个关键字，是一个引用，保存的内存地址指向对象本身，存储在jvm堆内存对象的内部，每一个对象都有，用在实例方法中，多数情况下可以省略
 static: 在类加载时执行
 		变量：类级别特征，对象共有特征，存储在方法区中，没有则代表是实例变量和实例方法(需要对象参与，即创建对象执行)
 		代码块：自上而下执行，在类加载时执行，并且只执行一次
 final: 表示最终的，不能变的, final修饰的类无法被继承，修饰的方法无法被覆盖，变量一旦赋值，无法重新赋值，实例变量需自动赋值，无法被垃圾回收器回收
 		常量：public static final String GUO_JIA = "值"
 
 #########################################################################################################
 
 
 访问控制权限：可以定义类，方法和属性
 			private	default	protected	public
 同一个类中	  √	      √	       √	       √
 同一个包中	  		  √	       √           √
 子类中		                   √	       √
 全局范围内			                       √
 
 public类，java文件名必须与类名相同。
 
 #########################################################################################################
 
 package包：方便分门别类管理类class
 语法：package 包名;
 命令规范：公司域名倒序 + 项目名 + 模块名 + 功能名;   //全部小写，不易重名
 一个包对应一个目录, 以.作为分割符
 类名：包名.class名
 import：导入包
 
 
 #########################################################################################################
 
 控制语句
 	选择结构语句： if  if else   switch
 	循环结构语句： for  while    do while
 	控制循环语句顺序：break continue   #作用于循环结构语句，break中断最近循环 continue跳过单前次循环继续后面的
 	
 if (布尔表达式){
 	java语句;
 	...
 }
 else if (布尔表达式){
 	java语句;
 	...
 }
 else{
 	java语句;
 	...
 }
 
 
 switch(expression){
     case value :
        //语句
        break; //可选，如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出直到遇到break
     case value :
        //语句
        break; //可选
     ...
     default : //可选
        //语句
 }
 
 //初始化 布尔表达式 更新  #初始值只执行一次
 // 可以都不写，但是两个;必须写。因为可以在外面定义
 for(初始化; 布尔表达式; 更新) {
     //代码语句
 }
 
 //do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次
 while( 布尔表达式 ) {
   //循环内容
 }
 
 do {
        //代码语句
 }while(布尔表达式);
 
 
 #########################################################################################################
 
 实例：
 //定义一个公开的类名,这个类名和文件名一致,可以没有，有则只能有一个
 public class  HelloWorld{
 /**
 *类体,不能写java语句，除了声明变量和方法
 *public             权限，公开的，任何地方都能访问
 *static				静态的，区别类级别和对象级别(类级别一般类加载自动执行还是对象级别需要创建对象自动执行，才能访问)
 					类级别访问：类.名称/类.名称()    对象级别访问: 引用.名称/引用.名称()    
 *void				空，该方法没有返回值
 *main				主方法
 *(String[] args)	main方法的形参列表，String[]是引用数据类型，args是局部变量名
 */
 	public static void main(String[] args){   //主方法，jvm程序执行入口，每个类都可以定义
 		//方法体，以;终止，字符串用""引起来
 		//向终端输出一段消息hello world!
 		//System.out.println("hello world!");
 		System.out.print("你好");
 	}
 }
 //可以有多个class，编译时每个class会对应生成一个以类名为文件名的class文件
 //如果执行改类，则需要有主方法main入口
 /*
 class A
 {     //没有定义main方法(程序入口)，通过创建对象引用进行调用
 }
 */
 
 
 
 方法体：
 //从内存向终端输出一段消息hello world!
 System.out.println("hello world!");
 
 //1.创建键盘扫描对象
 java.util.Scanner s = new java.util.Scanner(System.in);
 //2.调用scanner对象的next()方法开始接收用户键盘输入,以字符串形式接收
 String userInputContent = s.next()
 System.out.println("你输入了：" +userInputContent)
 
 
 
 #########################################################################################################
 
 其它
 
 1字节Bytes=8比特bit
 表达式Expressions是操作值的式子，语句是可执行代码(操作值的代码：命令+值)。
 
 
 命令集
 javac+*.java: 编译java源文件
 java+类名：执行字节码文件
 javadoc：解析注释
 native2ascii: 将汉字转换成16进制


 #########################################################################################################

 https://waylau.com/build-java-project-with-maven/
 maven使用
  
 安装：yum -y install maven
 查看版本：mvn --version    #检验安装
 创建本地仓库：mkdir /path/workspaceMaven
 配置: 配置文件/etc/maven/settings.xml 配置本地仓库 <localRepository>/path/workspaceMaven</localRepository>
 下载依赖：mvn help:system  #从中央仓库下载到本地仓库 输出信息是"Downloading:"


 java项目：
 
 创建项目项目目录结构：mkdir -p src/main/java/hello
 java文件
    cat<<eof>>src/main/java/hello/HelloWorld.java
    package hello;
    public class HelloWorld {
        public static void main(String[] args) {
            Greeter greeter = new Greeter();
            System.out.println(greeter.sayHello());
        }
    }
    eof
    cat<<eof>>src/main/java/hello/Greeter.java
    package hello;
    public class Greeter {
        public String sayHello() {
            return "Hello world!";
        }
    }
    eof
 在项目的根目录下创建一个Maven项目定义文件pom.xml
   java               #项目的根目录
   ├── pom.xml        #该文件主要是说明项目的名称、版本和依赖库
   ├── workspaceMaven #本地仓库,在settings.xml配置
   ├── src		       #项目目录	
   │   └── main
   │       └── java
   │           └── hello
   │               ├── Greeter.java
   │               └── HelloWorld.java
   └── target         #存放编译后文件和jar包
       ├── classes
       │   └── hello
       │       ├── Greeter.class
       │       └── HelloWorld.class
       └── generated-sources
           └── annotations
 编译Java代码:"Downloading:" 下载的依赖在本地仓库中
   mvn compile            #class文件在target/classes/
 运行项目：在项目根目录执行  
   mvn exec:java -Dexec.mainClass="hello.HelloWorld"

 mvn package    #在target目录下生成一个JAR文件，文件名由<artifactId> 和 <version>组成，会生成class文件 
 mvn install    #将项目代码将会经过编译、测试、打包并拷贝到本地依赖库，提供给其他项目引用









