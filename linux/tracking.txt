
都是使用ptrace系统调用跟踪调试运行中的进程
如果没有自动挂载proc文件系统的话:mount -t procfs proc /proc

[truss和]strace用来跟踪一个进程的系统调用(内核态)或信号产生的情况（静态库？）
top --> 1  查看cpu是内核态还是用户态负载高和负载高的进程pid
-o  -f  -p  -c  -e  -r(打印出相对时间戳) [-t(输出绝对时间戳) -T输出每个系统调用花费的时间]
strace -cp 24303
starce -T -e clone -p 24303

[pstack(gdb程序调试器)]和ltrace用来跟踪进程调用(用户态)库函数的情况（动态库？）
使用strace输出很少不代表进程很空闲



strace [-c] cmd [-o file]
strace -tt -f  cmd
strace [-tt -T] [-c] -vf -e trace=all -o /data/log/strace.log -s 1024 -p 23489
-tt 在每行输出的前面，显示毫秒级别的时间
-T 显示每次系统调用所花费的时间
-v 对于某些相关调用，把完整的环境变量，文件stat结构等打出来。
-f 跟踪目标进程，以及目标进程创建的所有子进程
-e 控制要跟踪的事件和跟踪行为,比如指定要跟踪的系统调用名称
-o 把strace的输出单独写到指定的文件
-s 当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是32个字节
-p 指定要跟踪的进程pid, 要同时跟踪多个pid, 重复多次-p选项即可。
   -e trace=file     跟踪和文件访问相关的调用(参数中有文件名)
   -e trace=process  和进程管理相关的调用，比如fork/exec/exit_group
   -e trace=network  和网络通信相关的调用，比如socket/sendto/connect
   -e trace=signal    信号发送和处理相关，比如kill/sigaction
   -e trace=desc  和文件描述符相关，比如write/read/select/epoll等
   -e trace=ipc 进程间通讯相关，比如shmget等
   -e trace=all	
	
LSOF：	匹配内容^表示取反 (/path/filename) (+d/+D dir) (-d fd) (-c <进程名> -c ...) (-u 用户名) (-p PID,PID...) (-i :port / 协议 / 协议:port/ 协议@url:服务名 / 协议@url:port ) -U(socket) -n(不dns) +/-r(持续) #协议指tcp和udp
	lsof | head
		COMMAND     PID   TID    USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
		删除恢复：
			1.lsof |grep /var/log/messages  
				USER使用COMMAND命令启动服务，进程ip是PID，线程id是TID，在DEVICE对类型TYPE，总大小SIZE，在磁盘上的索引节点NODE的文件NAME使用FD(文件描述符+操作方式)操作
			2.cat /proc/PID/fd/FD  >  <filename>

TCPDUMP:  or/and/not
	tcpdump -D | less [类型：host，net，port，portrange  方向：src，dst  协议：tcp，udp，IP，vlan，arp... 多条件组合：and，or，not]
	tcpdump (-i 接口) (-c 抓包总数) (or/and/not) (-w 文件) (-r 指定文件读出) (port PORT) (src/dst host ip/域名/网络位) (-p 协议) -t(不显示时间戳) -vv(详细输出) -nn(不dns)  #可以用'(条件)'形成复合条件,高级过滤方式proxy[x:y]...	
  tcpdump  -nn -i ens34 '(((dst host 104.193.88.77) or (dst host 104.193.88.123)) and (tcp[tcpflags] & (tcp-ack|tcp-fin|tcp-syn) !=0))'

ldd CMD:命令调用的库函数
