
https://www.hhcycj.com/post/item/331.html
如何使用变量的指针找到整个变量空间？
	通过变量指针找到变量的第一个字节
	根据变量的类型得到变量所占的总的字节，从第一个字节往后数，就能找到该变量空间所有的字节
内存的操作：
int main(void)
{
    int a = 10;	  //a变量代表的是a变量空间(变量的值),&a表示的是一个数，就是变量a的指针,即a区域的第一个字节的内存地址
    int b;
    int *pa = &a; // 把&a指针数字，赋值给pa(数字), *pa通过pa里存放的指针，找到所指向的变量空间
    *pa = 20;     // 修改了 a 变量空间的值，被设置为 20；等价于 a = 20;
    b = *pa;      // 等价于 b = a;
    printf("pa = %d \n", pa); // 输出的是指针数字； 输出 pa = 6356728
    printf("a = %d \n", a);   // 输出的是 a 变量空间里面值;  输出 a = 20
    return 0;
}
指针传参，可以突破这个作用域的限制(局部/全局变量)，通过指针指向相同的变量，修改的是对应内存地址的空间
指针占用空间大小：32位机4字节(32位)   64位机8字节(64位)--->应该是存储在符号表中
指针：
	1.指针的类型：#1和2是相同的，作用是帮助编译器发现你是否用了错误的类型
	2.指针所指向的类型：指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待
	3.指针的值：指针的值是内存区域的首地址(最小的那个字节的地址)
https://blog.csdn.net/u012826756/article/details/46859319
变量：用来标识(identify)一块内存区域(就像人一样，是一种分类)，这块区域的值一般是可以更改的，但通过变量的操作特性。用const修饰的使变量不能更改的就和常量一样的变量叫做常变量
变量名：变量名不占空间，是一个标识符(identifier)，用来指代一块内存区域
编译器：会搜集我们的变量名(变量名是给编译器看的)
假如定义了一个全局的int a; ,编译器会为程序预留4个字节的空间（假设在32位平台）,并把我们的变量名“a”保存进符号表，并用这个符号表的索引对应实际的空间。 
指针名、数组名、函数名它们分别表示指针所指向元素的地址、数组的首地址和函数的入口地址。  
https://blog.csdn.net/tyler_download/article/details/52437687
符号表本质上是一种数据库(整个符号表会直接存储在内存中)，用来存储代码中的变量，函数调用等相关信息。该表以key-value 的方式存储数据
{ 
	int variable = 0; 
}
在上面代码中，进入大括号时，解析器遇到变量的声明，于是便把变量variable 的相关信息写入符号表。当解析器读取到右括号时，便把variable在符号表中的信息给删除，因为出了variable的作用范围只在括号之内
个人理解：符号表可以用二维数组表示，x维存储变量名(转换成哈希)，y维存储层次(局部/全局变量)

对象就是键值对: 也可以看成json数据，是被构建出来的，没啥特别的

https://me.csdn.net/linyt
栈在进程中的作用如下：
	保存函数内的临时局部变量。
	调用函数时传递参数
	保存函数返回的地址
	函数调用的上下文
堆是指程序运行是申请的动态内存，而栈(堆栈)只是指一种使用堆的方法(即先进后出)
（1）程序内存布局场景下，堆与栈表示两种内存管理方式；
	堆由开发人员分配和释放(动态)， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表
	栈由操作系统自动分配释放(静态和动态)，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈
	理论上，每个进程拥有的栈的大小要远远小于堆的大小
	分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持，堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多
	存放内容不同：堆中具体存放内容是由程序员来填充的，栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等
（2）数据结构场景下，堆与栈表示两种常用的数据结构。
	栈是一种运算受限的线性表---只有一个口，所以是先进后出
	堆是一种常用的树形结构，是一种特殊的完全二叉树
	
堆和栈一个向上涨，一个向下涨：划出一块空间，一个从上往下，一个从下往上，这样就能既简单有充分利用空间	

汇编中有ret相关的指令，它表示取出当前栈顶值，作为返回地址，并将指令指针寄存器EIP修改为该值，实现函数返回
rbp和rsp，rip只是32位ebp和esp，eip变量的64位等价物
栈是向下生长的，存储东西越多，内存地址越来越小

eip：指令地址寄存器，指向指令所在地址
esp：指向当前的栈顶
ebp：指向了本次函数调用开始时的栈顶指针(栈基地址寄存器，指向栈底地址)
ebp(帧指针Frame Pointer)和esp(栈指针Stack Pointer)之间的空间被称为本次函数调用的“栈帧”

数据执行保护DEP：可以监控您的程序以确保其安全地使用系统内存(将非代码段的地址空间设置成不可执行属性),如果发现计算机上的程序错误地使用内存，则会关闭此程序并通知您。

栈溢出stackoverflow：
	超出低地址范围的overrun(上溢)：主要是由过深的函数调用引起(比如递归调用)
		对于那些不使用虚拟内存机制的RTOS，通常采用的做法是在stack创建之初就填充满固定的字符(比如0x5a5a5a5a)，如果发生了"上溢"，那么stack末端(最低地址处)的填充字符则有可能会被更改。
	超出高地址范围的underrun(下溢)：
		可以在将函数的返回地址压栈的时候，加上一个随机产生的整数，如果出现了数组越界，那么这个整数将被修改，这样在函数返回的时候，就可以通过检测这个整数是否被修改，来判断是否有"下溢"发生。
		只需要在gcc编译的时候，加入"-fstack-protector"选项即可

内存随机化保护ASLR(Address Space Layout Randomization)技术就是通过加载程序的时候不再使用固定的基址加载(将栈，堆和动态库空间全部随机化)，从而干扰shellcode定位的一种保护机制


c文件：主要每个模块的原代码都在c文件中。
h文件：每个c文件都跟着一个h文件，h文件的作用是放着c文件中函数的声明，结构体的定义，宏的定义等。
s文件：.c 文件经过汇编器处理后的汇编文件，不可以在这里面加入预处理的命令
S文件：在编译汇编文件之前会进行预处理操作，可以在这里面加入预处理的命令
搜索结果
网上的精选摘要
o文件：又称对象文件，是可执行文件。里面包含了对各个函数的入口标记，描述
	当程序要执行时还需要链接(link). 链接就是把多个.o文件链成一个可执行文件。
	当多种编程语言希望混合编译时，就可以通过分别编译成.o文件，再链接（link）成可执行文件
a文件：静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝	
so文件可以用于多个进程的共享使用(映射)，所以又叫共享库文件	
ELF是非常灵活的二进制格式

向后兼容：在旧版本上开发的目标，或者旧版本生成的数据，能够在新版本正确运行，或者正确处理
	只新增接口，对现有接口不能做任何修改，同时可感知到的默认行为都要保持不变
	保留原有接口，开发一个同名的新接口，但接口版本号不同
向前兼容：在新版本上开发的目标，或者新版本上生成的数据，能够在旧新版本上运行，或者处理

利用旧知识构建新知识：
一天，数学家觉得自己已受够了数学，于是他跑到消防队去宣布他想当消防员。 消防队长说：“您看上去不错，可是我得先给您一个测试。”
消防队长带数学家到消防队后院小巷，巷子里有一个货栈，一只消防栓和一卷软管。消防队长问：“假设货栈起火，您怎么办？”
数学家回答：“我把消防栓接到软管上， 打开水龙，把火浇灭。”消防队长说：“完全正确！最后一个问题：假设您走进小巷，而货栈没有起火，您怎么办？”数学家疑惑地思索了半天，终于答道：“我就把货栈点着。” 消防队长大叫起来：“什么？太可怕了！您为什么要把货栈点着？”
数学家回答：“这样我就把问题化简为一个我已经解决过的问题了。”

知识系统化：在旧知识的框架下，添加一个新知识节点

该知识的历史，它的出现是为了解决什么问题的？ 
该知识本身是怎么样的，它的定义，它的原理 
如何应用该知识

按分层进行设计和交流：
	第一阶段：整点介绍你的期望和目标
	第二阶段：要设计各功能区整体的布局
	第三阶段：细节设计了，根据个人的实际喜好和需求进行安排	


