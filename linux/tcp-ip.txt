
	端对端(end system):服务端和客户端
	中间系统(intermediate system): 路由器
	应用层和传输层：端到端(end-to-end)
	网络层提供的逐跳(hop-to-hop)：pc和路由器
	tcp在不可靠的ip层上提供一个可靠的运输层，分层目的之一是在应用程序中隐藏所有的物理细节
	
	##############################################################################
	
	Socket是对TCP/IP协议的封装，是一组接口,socket连接是长连接(不会主动断掉), 包含五元组：ip 端口 协议   #当两台主机通信时，必须通过Socket连接
	http协议是建立在TCP协议之上的一种应用，http连接是短连接
	WebSocket是双向通信协议(websocket和http都是应用层协议)，可以双向发送或接受信息。HTTP是单向的
	WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。
	传输数据时，可以只使用（传输层）TCP/IP协议，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议
	建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。
	若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则需要等到客户端发送一次请求后向服务端发送连接请求
	
	##############################################################################
	
	协议：一组控制数据通信的规则，对等层之间的操作
	标准化组织：ISO   IYU-T   ANSI  IEEE  EIA
	iso是一个组织，osi是一个模型
	internet标准：rfc
	对等层通信/对等实体/对等层协议
	pdu：协议数据单元（比特流bit 帧frame 分组packet 数据段segment 数据data(应用层)）
	数据链路层添加头部和尾部，检验，其它层只添加头部，对等层实体之间的通信
	
	##############################################################################
	
	https://blog.csdn.net/huangjin0507/article/details/51613561
	tcp/ip：在当前结构下，完成的一次网络传输。tcp连接应用层和ip连接数据链路层
	OSI七层模型: 概念模型，定义功能，但没有具体的功能实现
	TCP/IP 五/四层模型的协议：实现具体功能后提炼出来的（五层多了物理层，不是协议层次模型）
	
	！！
	转发数据需要pdu相同的层次才能转发，例如路由器转发可以忽略数据链路层和物理层的区别(路由器可以连接以太网络和拨号网络)
	pdu不同，封装不同，实现寻址机制不同
	路由器转发：路由器从端口中接收数据包之后，进行数据链路层帧头的拆包。并从网络层的ip数据报头中获取目的ip地址，根据路由表进行转发（有前提(物理地址不等于mac地址) ##如果路由器中没有下一跳的mac地址，则进行mac广播（源和目的mac地址产生变化，源和目的ip地址不变））
	前提：三层的跟三层的通讯就不会有MAC(会不会取决于链路层技术，因为物理地址包含mac地址)，三层的跟二层或一下的通讯肯定会用到MAC地址(这句话是因为物理协议不同，不一定的)
	
	
	不同节点(路由器和计算机...)，层次组成不同，作用不同
	编址：物理地址(局域网内使用 链路层)   ip地址(因特网32bit 点分法表示 网络层)   端口地址(进程16bit传输层)
	目的地址： 单播unicast    多播multicast(一组)   广播broadcast(子网内所有节点)
	
	##############################################################################
	
	物理层是将数据广播出去的(交换机---先广播后交换)
		堆叠(局域网)是指将一台以上的交换机组合起来共同工作，以便在有限的空间内提供尽可能多的端口(交换机的作用是提供更多的端口，路由器端口太少)
		城域网是交换机级联的极好例子
	以太网是物理层的，冲突域在该层发生
	以太网数据包大小：46-1500  #有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的最大帧长为1500
							#历史遗留问题，早期的以太网使用总线拓扑，网络中多台设备共享一个物理信道。过短的帧会导致帧传输时间非常小，这样就导致了多台设备同时发送信号的时候会发生碰撞---冲突域，导致数据失真
							#如果以太网提升带宽，但是又要保证最小帧长度不变，就不得不牺牲线路的传输距离。因为带宽提高时，发送相同长度的数据帧的时间会缩短，这就解释了为什么以太网带宽越来越大，但是最长传输距离却越来越小。
	广域网只能使用交换方式，独享物理通道
	
	
	数据转发：网卡/中继器bit--网桥/交换机(多端口的网桥)--路由器--网关(上四层)
	
	##############################################################################
	
	ip地址--通用标识符：唯一 标识 互联网 上的 主机或路由器
	格式：网络位/标识网络 + 主机位/标识节点
	网络位置：当一个主机从一个网络改接另一个网络时，ip地址(网络位)必须改变
	
	主网/分类网(major network)
	A类：0 + 7netid + 24hostid      ---  0.0.0.0~127.255.255.255
	B类: 10 + 14netid + 16hostid    ---  128.0.0.0~191.255.255.255
	C类：110 + 21netid + 8hostid    ---  192.0.0.0~223.255.255.255
	D类: 1110 + 28multicast         ---  224.0.0.0~239.255.255.255
	E类：11110 + 27reserved         ---  240.0.0.0~255.255.255.255 保留
	多播multicast：本地级或全局级(不同网络)
	广播：本地级(同一个网络)
	netid 作用于不同网络(转发) hostid作用于同一个网络
	环回地址: 127.x.x.x    #只会作用于本机，进程间通信，拆包只需到网络层，不会被发送到网络上去
	特殊地址：hostid全部为0表示网络地址 全部为1表示广播地址
	
	无类ip编址：
	子网划分：共享netid和subnetid前缀
		作用：将大网划分为小网
		三层次结构：netid -- subnetid -- hostid
		掩码：标识网络大小(1表示netid和subnetid , 0表示hostid)，使用的是连续掩码
		掩码运算：位与运算
		可用ip地址数：2^(hostid位数)-2(网络地址和广播地址)
		划分方法：前提是netid -- subnetid已确定
			定长子网划分：有5个子网(掩码固定)，所需ip:8+30+43+53+63   每个子网都要63个以上，所以是255.255.255.192（ip地址总空间：5*64=320）
			变长子网划分: 掩码不固定
		10.1.0.0/27   10.1.0.32/27
			ip地址数：2^(hostid位数)~2^(hostid位数)的倍数-1     10.1.0.0~10.1.0.31   10.1.0.32~10.1.0.63
			子网地址：网络地址，是2^(hostid位数)的倍数		  	10.0.0.0			 10.0.0.32
			子网广播地址：2^(hostid位数)的倍数-1			  	10.1.0.31			 10.1.0.63
			主机地址：除去网络地址和广播地址				  	10.1.0.1~10.1.0.30	 10.1.0.33~10.1.0.62
			
	超网划分：#无类别域间路由选择（CIDR）
		作用：将C类连续小网合并成大网，超网内部可以使用子网技术
		二层次结构：netid -- hostid
		
	无类别域间路由选择（CIDR）：使用超网技术减少路由表项的技术，可以将任何类型的网络聚合，是一种路由技术
	
	##############################################################################
	
	多接口设备：
		主机：可以连接同/不同的网络
		路由器：需要连接不同的网络，网络间通信
	
	ip协议：解决网络间分组交付问题
	交付delivery：对分组的物理转发
	路由routing：路由选择，为分组寻找路由
	路由协议：寻找到达目的的最佳路径，沿选定的路径交付分组
	
	协议：对等层之间的操作
	服务：在osi模型中，指下层为上层提供的一组操作
	
	交付方式判断：使用掩码判断
		直接交付：分组的目的与分组的发送接口在同一个IP网络中
		间接交付：分组的目的与分组的发送接口在不同的IP网络中
	交付操作：地址映射		#也就是说路由器之间的传输也需要物理地址(以太网是mac地址)
	直接交付：目的ip地址-->物理地址
	间接交付：下一跳ip地址-->物理地址
	
	默认网关：路径，间接交付使用
	
	一次交付过程：物理地址包含但不等于mac地址
		0/多个间接交付+1个直接交付
		分组：源ip地址和目的ip地址保持不变
		帧：源物理地址和目标物理地址，逐跳改变   #也就是说路由器之间的传输也需要mac地址
		
	路由选择：先预定路由(路由表)后转发
		思路：使用尽可能少的信息实现选路
		信息：目的网络(使用少表项表示多主机)，下一跳路由(每台路由器独立，并维护自己的路由表)
		选路：主机--路由器--路由器...主机(路由器是独立的，独立选路，因此能选出当前最优的路径，只有最后一个路由器才知道目的主机是否存在)
	
		
	##############################################################################
	
	ip协议：不可靠无连接数据报协议	
    ip分组：根据不同底层技术实现，传输数据包太大时候，根据ip协议，对数据包进行分片	
	连接：面向连接，无连接
	可靠：差错控制，流量控制等
	面向连接和可靠不是必然对应关系
		
	源主机：ip分组进行无连接(可能出现不同传输路径)传输
	目的主机：通过源IP地址和标识分类，再通过offset进行重组	
		
	校验和算法：源主机：协议数据头+内容+校验位(0) -- 转化成16bit 相加得到一个16bit的值填到 校验位上   目标主机：把包数据转化成16bit相加等于0	
	
		
	##############################################################################
	
	arp：适用于链路层的以太网协议  网络层
	代理arp
	
	##############################################################################
	
	icmp：网络层
	ip的辅助协议，为ip、其ip/其它层提供差错报告机制
	
	##############################################################################
	
	传输层：端到端，进程与进程间的通信
	
						报文      			数据流
	投递单位：  		报文      			byte
	可靠性：    		按序接收  			按序接收
	连续报文/数据流		报文边界  			无边界
	接收					大小和顺序与发送方相同
	发送                前后报文不能合并  	前后字节能合并	
	
	！！
	tcp：
	按字节序号排序，保证顺序正确
	面向连接：虚电路连接(逻辑连接)
	字节流形式，发送任意，可以单个字节或者合并成数据块(应用程序决定)，
		字节流：tcp和应用程序传输数据
		报文：tcp与下层传输数据
	tcp层缓冲区：接收应用程序数据，合并或者分割再发送(应用程序可以强制push)，包含窗口
	tcp对等层全双工
	
	
	报文字段：
		序号：按序号排序，保证顺序正确
		带外数据：位于数据字段的开始，例如ctrl+c，不在数据流中排队，直接递交给上次，提供快速传递数据的功能 
		紧急指针：指向带外数据的最后一个字节
		
		#tcp报文段封装在ip数据报传输，分片会导致整个ip分组的传输完整性(缺一tcp需要重传)
		选项：
		最大报文段长度MSS：tcp建立连接时 ，协商报文段长度   #不能太大(分片降低成功传输概率) 太小(报文开销)
		窗口比例因子：连接建立确定，作用是改变窗口大小    
			#tcp窗口：每次传输的最大字节数据量（其它可能是报文数据量），是发送缓冲区的一部分  
		时间戳：用来测量往返时间，动态定义超时时间
	
	差错控制：检验和，肯定确认机制(回复希望接收的下一字节)，超时重传机制(自适应超时重传算法)
	流控：滑动窗口机制
		流量控制：收发速率匹配(窗口通告值：接收方可用缓冲区)
		拥塞控制：表现为时延增加，基于滑窗机制，减少报文段的发送数和窗口大小（拥塞窗口）
	发送窗口：min(窗口通告值,拥塞窗口)
	糊涂窗口综合征：通信双方的应用程序以不同速率工作，出现的性能问题(发送有效数据太小)  #解决方法：推迟窗口通告/推迟窗口确认
	
	
	###########################
	
	连接管理：有限状态机
		有限状态机： 状态个数是有限的。直观，全局，准确的协议描述方法。实质就是状态转换图
			要素：状态1 --事件/动作-- 状态2
			
		tcp连接：占用内存 ，接收/发送缓冲区 ，状态维护...
		tcp连接序号，第一个序号是随机值，由tcp三次握手协商确定  
		
		tcp连接复位：无法恢复，异常/强制中断(RST)
		
	
	##############################################################################
	
	路由协议: 应用层实现网络层的功能
	选路准则：最短路径
	不同的metric产生不同"最短路径"，不同路由协议采用不同类型的metric，一个路由协议可同时应用多次metric
	metric(度量):
		跳数hop count:经过路由器的数目
		带宽bandwidth 延迟delay 负载load 开销cost
	convergence收敛:采用特定路由协议的所有路由器对整个网络拓扑具有一致性的认识
		收敛时间：从不一致到一致所经历的时间，体现路由算法的效率
	
	自治系统AS：一个 管理机构 控制下的网络和路由器的集合，可自主选择其内部路由方式和对外通告部分可达性信息的权利
	外部网关协议：BGP-4    内部网关协议：RIP,OSPF,IS-IS
	RIP:  距离向量路由算法(D-V) -- 以广播方式周期性的向邻居路由器发送路由表(跳数)
		RIP通过UDP 520端口报文，维护ip模块中的路由表
	OSPF: 链路状态路由算法(L-S) -- 通过ospf在ip中的协议值是89，直接封装在ip分组中传输出去
	
	
	##############################################################################
	
	dns：
	递归：返回的是ip(可能通过多个dns服务器)
	迭代：返回的是下一个dns服务器的位置
	udp：<512字节,如果丢失，由应用层负责重传
	tcp >=512字节,如果丢失，由tcp层负责重传


	##############################################################################

	！！
	为什么有mac地址还需要ip地址？
		mac地址：设备到设备之间
		ip地址：不同网路之间      #减少路由器内存和减少路径数(类似dns查询)
	
	三层协议：arp  ip  icmp
	交换机内部有mac地址表(记录接口和mac地址的映射)，但接口没有mac地址,会进行arp广播
	路由器不会进行arp广播，但会通过arp协议获取mac
	只有能配置ip地址的地方才能有mac地址(pc和路由器)
	pc和路由器都有mac地址表
		1.路由器收到帧检查mac地址是否为自己的，是的话会拆帧(不是则丢弃)
		2.获取目标ip 经过路由器内部路由表路由，找到出口ip和下一跳ip(无法路由则丢弃并向源IP回馈错误信息)  
		3.通过arp缓存表或者通过arp获取mac地址，再次进行封装并发送帧
	
	帧数据包格式：总长1518字节
	帧头：
		目标MAC(6)：下一跳MAC
		源  MAC(6)：
		类型(2)：上层协议   
	帧尾(4)：
	# mtu(最大传输单元):1500字节  #由上层分片
	
	ip数据包格式：
		版本(4)：ipv4/ipv6
		首部长度(4)：ip数据包头长度
		优先级与服务类型(8)：设置服务优先级选项
		总长度(16)：三四五层数据长度
		标识符(16)：同一报文是一样的
		标志(3)：标识分片开头(2)和结束(3)   #根据策略，如果不允许分片通过，会回包让源5层软件自己分片。
		段偏移量(13)：重组使用
		ttl(8)：每经过一个路由器，该值就减一，到零丢弃
		协议号(8)：上层协议
		首部检验和(16)：IP数据包头部的校验和
		源地址(32)：
		目标地址(32)：
		可选项：0-40字节
		
	tcp: 1480
	
	软件层:1460



##################################################################################


CLOSED(客/服)：初始状态，表示TCP连接是“关闭着的”或“未打开的”。

LISTEN(服)：服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。

SYN_SENT(客)：客户端发送SYN(J)报文，然后随即进入到SYN_SENT 状态，很短暂

SYN_RCVD(服)：服务器接收到了来自客户端请求连接的SYN报文,然后发送SYN(J)+ACK(J+1)，很短暂

ESTABLISHED(客/服)：表示TCP连接已经成功建立。1.客户端收到服务端的SYN+ACK，然后发送ACK(K+1), 2.服务端收到客户端的ACK 

FIN_WAIT_1(客)：客户端主动关闭连接发送了FIN(M)报文，很短暂(实际的正常情况下，服务器无论处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的）
				如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）
				
CLOSE_WAIT(服) ：服务端接回应一个ACK(M+1)报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。

FIN_WAIT_2(客) ：客户端收到服务端发送的ACK(M+1)，FIN_WAIT_2状态下的SOCKET表示半连接注意：FIN_WAIT_2 是没有超时的,这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。

LAST_ACK(服) ：服务端发送FIN(N)报文，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。

TIME_WAIT(客) ：客户端收到了对方的FIN报文，并发送出了ACK(N+1)报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。

CLOSED(服)：服务端在LAST_ACK状态下收到ACK(N+1)报文


CLOSING ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。



