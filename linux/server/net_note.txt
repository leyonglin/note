 
 NAT网络地址转换：静态NAT：一对一
                  动态NAT：IP地址的对应关系是不确定的
 				  端口多路复用PAT：内部网络的所有主机均可共享一个合法IP地址实现互联网的访问，节约IP
 				 
 TCP Multiplex：	改变外出数据包的源端口并进行端口转换，将多路请求合并到一路 TCP 上			
 
 kcp采取一系列措施尽量提高网络传输速率，在网络实时性和可靠性要求比较高的场景下可以考虑kcp协议代替tcp协议。 
 
 程序的可运行机器码的一个在存储器的映像。 分配到的存储器（通常包括虚拟内存的一个区域）。存储器的内容包括可运行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运数中途产生的数据）。 分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。 处理器状态（内文），诸如寄存器内容、物理存储器寻址等。当进程正在运行时，状态通常储存在寄存器，其他情况在存储器。
 每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。
 
 IOPS（Input/Output Per Second）即每秒的输入输出量（或读写次数）
   
   netstat -antp | grep pid  查看连接状态
   awk  '{ip[$1]++} END{for(i in ip) {print ip[i],i}}' ip.txt | sort -nr 
   netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
   awk [ 选项] ' BEGIN{ 指令} { 指令} END{ 指令} ' 文件
 
 协议栈（英语：Protocol stack），又称协议堆叠，可以理解为代码、函数库、供上层应用调用。商业化的协议栈就是给你写好了底层的代码，符合协议标准，提供给你一个功能模块给你调用。你需要关心的就是你的应用逻辑，数据从哪里到哪里，怎么存储，处理还有系统里的设备之间的通信顺序什么的。所以当你做具体应用时，不需要关心协议栈是怎么写的，里面的每条代码是什么意思。
 
 网络接口层=物理层+数据链路层   应用层=会话层+表示层+应用层
  
 RFC：是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件
 
 CCProxy：主要用于局域网内共享宽带上网，ADSL共享上网、专线代理共享、ISDN代理共享、卫星代理共享、蓝牙代理共享和二级代理等共享代理上网。
 
 tcp五元组：源端口 目标端口 源ip 目标IP 协议
 
 IPS：互联网协议族（英语：Internet Protocol Suite），是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为 TCP/IP 协议族
 
 应用层的各种网络应用程序基本上都是通过 Linux Socket( 属于文件系统的一部分)编程接口来和内核空间的网络协议栈通信的。Linux Socket 是从 BSD Socket 发展而来的，它是 Linux 操作系统的重要组成部分之一，它是网络应用程序的基础。从层次上来说，它位于应用层，是操作系统为应用程序员提供的 API，通过它，应用程序可以访问传输层协议。
 传输层的最终目的是向它的用户提供高效的、可靠的和成本有效的数据传输服务，主要功能包括 （1）构造 TCP segment （2）计算 checksum （3）发送回复（ACK）包 （4）滑动窗口（sliding windown）等保证可靠性的操作。TCP 协议栈的大致处理过程如下图所示： 
 网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。其主要任务包括 （1）路由处理，即选择下一跳 （2）添加 IP header（3）计算 IP header checksum，用于检测 IP 报文头部在传播过程中是否出错 （4）可能的话，进行 IP 分片（5）处理完毕，获取下一跳的 MAC 地址，设置链路层报文头，然后转入链路层处理。
 数据链路层在不可靠的物理介质上提供可靠的传输,建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输
 OSI将层与层之间交换的数据的单位称为服务数据单元SDU。
 数据单位：bit--frame--packet--segments/datagrams---数据(data)/报文
 MTU是网络接口层的限制(该网络设备能够传输的最大帧（frame）的大小)，而MSS是传输层的概念。其实这就是 TCP分段 和 IP分片 。MSS值是TCP协议实现的时候根据MTU换算而得(减掉Header)。当一个连接建立时， 连接的双方都要通告各自的MSS值。
 
 每一层添加的 Header(TCP/UDP Header, IP Header, Data Link Header) 都是为了实现该层协议服务而必须存在的协议相关数据。
 Netfilter:Linux内核中的防火墙实现模块。也就是我们使用iptables调用的功能。提供了包过滤和地址转换功能。
 
 用户层创建数据，调用write系统调用发送数据。
 一旦执行系统调用，系统则进入内核层。对于类Linux系统，通过文件描述符关联socket和应用，内核中socket包含收发两块buffer。
 在系统调用执行数据将被拷贝至内核memory当中，然后添加至发送buffer尾部，即按序发送。
 在TCP层，TCB(TCP Control Block) 关联socket，如果TCP允许数据发送，内核创建TCP segment。否则，由于规则或者流量控制会将该报文丢弃。至于TCP segment报文格式，无外乎一个header加payload，还有个checksum。TCP校验和往往由网卡进行计算。
 继续在TCP segment上封装IP层，再算下IP校验和，就可以扔给网络层了，比如以太网层。
 以太网层开始查找下一跳IP的MAC地址，一旦完成将继续封装Etherent头，最终送往driver层，这里往往也是各大抓包工具进行数据拷贝的地方，比如tcpdump/wirshark，或者是自己写的抓包工具；流量整形也往往在这一层完成。
 driver层在收到发送请求之后，通过DMA将该主存中的数据拷贝至内部RAM之中。在数据拷贝中，同时加入符合以太网协议的相关header，IFG、前导符和CRC。对于以太网网络，物理层发送采用CSMA/CD,即在发送过程中侦听链路冲突；而对于Wi-Fi网络，则采用CSMA/CA，其基本思想是要想占用channel并发言，首先做好聆听（也是做人哲学之一），对于需要ACK的报文，一旦在规定时间内搜不到ACK，则重传该报文。
 一旦网卡完成报文发送，将产生中断通知CPU。
 
 CPU工作方法分为中断模式和查询模式.  时间：切片
 查询模式就是说CPU轮翻的对外设顺序访问,效率低.但稳定可靠.适合处理数据量大
 中断模式时就是说CPU不主动访问这些设备,,只管处理自己的任务,没任务就闲着.也就是说在那等着.如果有设备要与CPU联系,或要CPU处理一些事情,他会给CPU发一个中断请求信号.一种情况是这时CPU就会放下正在进行的工作而去处理这个外设的要求.这叫做响应中断.处理完中断后,CPU返回去继续执行中断以前的工作.
           如果CPU这时正在做更重要的事情他就会让这个设备先在那等着.有空时响应他.如果同时有好几个设备都要CPU来处理,CPU就会从按重要程度来逐个处理.这就是中断和中断的优先级。适合数据量小
 NAPI(new API)是综合中断方式与轮询方式的技术。为了解决网络对CPU的影响而引入的。NAPI 可以有效的减少网络对CPU中断而导致的上下文切换次数，减轻导致的CPU性能损耗。网卡驱动必须提供轮询方法poll()。内核接口为napi_schedule()
 
 单工数据传输只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，举例：电视，广播。
 半双工数据传输允许数据在两个方向上传输,但是,在某一时刻,只允许数据在一个方向上传输,它实际上是一种切换方向的单工通信；在同一时间只可以有一方接受或发送信息，可以实现双向通,举例：对讲机
 全双工数据通信允许数据同时在两个方向上传输,因此,全双工通信是两个单工通信方式的结合,它要求发送设备和接收设备都有独立的接收和发送能力；在同一时间可以同时接受和发送信息，实现双向通信，举例：电话通信
 ethtool -s eth0 speed 100 duplex full autoneg off 此指令将eth0设备设置为全双工自适应，速度为100Mbs
 
 tcp--checksum    数据链路层--差错控制
 skb：socket_buffer 套接字缓存
 struct sock 有三个队列（queue），分别是 rx , tx 和 err
 
 三次握手建立连接：
 1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SENT状态，等待服务器B确认。
 2）第二次握手：服务器B收到SYN包，必须发生一个ACK包，来确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
 3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手(注意，主动打开方的最后一个ACK包中可能会携带了它要发送给服务端的数据)。
 总结：三次握手，其实就是主动打开方，发送SYN，表示要建立连接，然后被动打开方对此进行确认，表示可以，然后主动方收到确认之后，对确认进行确认；
 四次挥手断开连接：
 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，TCP的双方都要向对方发送一次 FIN 包，并且要对方对次进行确认。根据两次FIN包的发送和确认可以将四次挥手分为两个阶段：
 第一阶段：主要是主动闭方方发生FIN，被动方对它进行确认；  
 1）第一次挥手：主动关闭方，客户端发送完数据之后，向服务器发送一个FIN(M)数据包，进入 FIN_WAIT1 状态；
                      被动关闭方服务器收到FIN(M)后，进入 CLOSE_WAIT 状态；
 2）第二次挥手：服务端发送FIN(M)的确认包ACK(M+1)，关闭服务器读通道，进入 LAST_ACK 状态；客户端收到ACK(M+1)后，关闭客户端写通道，
                      进入 FIN_WATI2 状态；此时客户端仍能通过读通道读取服务器的数据，服务器仍能通过写通道写数据。
 第二阶段：主要是被动关闭方发生FIN，主动方对它进行确认；
 3）第三次挥手：服务器发送完数据，向客户机发送一个FIN(N)数据包，状态没有变还是 LAST_ACK；客户端收到FIN(N)后，进入 TIME_WAIT 状态
 4）第四次挥手：客户端返回对FIN(N)的确认段ACK(N+1)，关闭客户机读通道(还是TIME_WAIT状态);
                      服务器收到ACK(N+1)后，关闭服务器写通道，进入CLOSED状态。  (2MSL  1/2/4)
 
 总结：
 四次挥手，其本质就是：
 主动关闭方数据发生完成之后 发生FIN，表示我方数据发生完，要断开连接，被动方对此进行确认；
 然后被动关闭方在数据发生完成之后 发生FIN，表示我方数据发生完成，要断开连接，主动方对此进行确认；
 在TCP层，有个FLAGS(标志位)字段
         SYN表示建立连接，
         FIN表示关闭连接，
         ACK表示响应，
         PSH表示有 DATA数据传输，
         RST表示连接重置。
	Source Port & Destination Port (来源端口 & 目标端口)
	Sequence Number (封包序号)由于 TCP 封包必须要带入 IP 封包当中，所以如果 TCP 数据太大时(大于 IP 封包的容许程度)， 就得要进行分段。这个 Sequence Number 就是记录每个封包的序号，可以让收受端重新将 TCP 的数据组合起来。
	Acknowledge Number (回应序号)为了确认主机端确实有收到我们 client 端所送出的封包数据，我们 client 端当然希望能够收到主机方面的响应，那就是这个 Acknowledge Number 的用途了。 当 client 端收到这个确认码时，就能够确定之前传递的封包已经被正确的收下了。
	Data Offset (资料补偿)倒数第二行有个 Options 字段对吧！那个 Options 的字段长度是非固定的，而为了要确认整个 TCP 封包的大小，就需要这个标志来说明整个封包区段的起始位置。
	Reserved (保留)未使用的保留字段。
	Code (Control Flag, 控制标志码)
		当我们在进行网络联机的时候，必须要说明这个联机的状态，好让接收端了解这个封包的主要动作。 这可是一个非常重要的句柄喔！这个字段共有 6 个 bits ，分别代表 6 个句柄，若为 1 则为启动。分别说明如下：
		URG(Urgent)：若为 1 则代表该封包为紧急封包， 接收端应该要紧急处理，且图 2.4-1 当中的 Urgent Pointer 字段也会被启用。
		ACK(Acknowledge)：若为 1 代表这个封包为响应封包， 则与上面提到的 Acknowledge Number 有关。
		PSH(Push function)：若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无须等待缓冲区满了才送。
		RST(Reset)：如果 RST 为 1 的时候，表示联机会被马上结束，而无需等待终止确认手续。这也就是说， 这是个强制结束的联机，且发送端已断线。
		SYN(Synchronous)：若为 1，表示发送端希望双方建立同步处理， 也就是要求建立联机。通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
		FIN(Finish)：若为 1 ，表示传送结束，所以通知对方数据传毕， 是否同意断线，只是发送者还在等待对方的响应而已。
		其实每个项目都很重要，不过我们这里仅对 ACK/SYN 有兴趣而已，这样未来在谈到防火墙的时候，你才会比较清楚为啥每个 TCP 封包都有所谓的『状态』条件！那就是因为联机方向的不同所致啊！底下我们会进一步讨论喔！ 至于其他的数据，就得请您自行查询网络相关书籍了！
	Window (滑动窗口) 主要是用来控制封包的流量的，可以告知对方目前本身有的缓冲器容量(Receive Buffer) 还可以接收封包。当 Window=0 时，代表缓冲器已经额满，所以应该要暂停传输数据。 Window 的单位是 byte。
	Checksum(确认检查码) 当数据要由发送端送出前，会进行一个检验的动作，并将该动作的检验值标注在这个字段上； 而接收者收到这个封包之后，会再次的对封包进行验证，并且比对原发送的 Checksum 值是否相符，如果相符就接受，若不符就会假设该封包已经损毁，进而要求对方重新发送此封包！
	Urgent Pointer(紧急资料) 这个字段是在 Code 字段内的 URG = 1 时才会产生作用。可以告知紧急数据所在的位置。
	Options(任意资料)目前此字段仅应用于表示接收端可以接收的最大数据区段容量，若此字段不使用， 表示可以使用任意资料区段的大小。这个字段较少使用。
	Padding(补足字段) 如同 IP 封包需要有固定的 32bits 表头一样， Options 由于字段为非固定， 所以也需要 Padding 字段来加以补齐才行。同样也是 32 bits 的整数。	 
	
 
 recv-Q 表示网络接收队列(receive queue):表示收到的数据已经在本地接收缓冲，但是还有多少没有被用户进程取走，如果接收队列Recv-Q一直处于阻塞状态，可能是遭受了拒绝服务 denial-of-service 攻击。
 send-Q 表示网路发送队列(send queue)发送了，但是没有收到对方的Ack的, 还保留本地缓冲区.如果发送队列Send-Q不能很快的清零，可能是有应用向外发送数据包过快，或者是对方接收数据包不够快。
 
 dmesg | grep -in ens
 ls /usr/src/kernels/    /   uname -r
 lsmod / modprobe  / depmod   模块
 ifconfig dev /  hostname -- hostnamectl --cat /etc/sysconfig/network  / hosts   ip/主机名/dns/gw
 /etc/protocols    封包协议的定义
      预设路由==默认路由
 
 
p2p软件：指数据的传输不再通过服务器，而是网络用户之间直接传递数据，最初的含义是Peer-to-peer，之后的含义是Point to point（点对点）

BT下载（变态下载:是一个网络文件传输协议)是一个多点下载的源码公开的P2P软件，使用非常方便，就像一个浏览器插件，很适合新发布的热门下载。其特点简单的说就是：下载的人越多，速度越快。BitTorrent下载工具软件可以说是一个最新概念P2P的下载工具、它采用了多点对多点的原理
BT首先在上传者端把一个文件分成了Z个部分，甲在服务器随机下载了第N各部分，乙在服务器随机下载了第M个部分，这样甲的BT就会根据情况到乙的电脑上去拿乙已经下载好的M部分（下载完不马上关闭BitTorrent软件）
人们就把发出下载文件的人叫做种子。而种子文件就是记载下载文件的存放位置、大小、下载服务器的地址、发布者的地址等数据的一个索引文件。

P2P网络的时候都需要借助一个叫Tracker的中心服务器，这个服务器是用来登记有哪些用户在请求哪些资源，然后让请求同一个资源的用户都集中在一起互相分享数据，形成的一个集群叫做Swarm
DHT（Distributed Hash Table）的去中心化网络。每个加入这个DHT网络的人都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。在DHT里定位一个用户和定位一个资源的方法是一样的，他们都使用SHA－1产生的哈希值来作标识。
 

 

 


 
