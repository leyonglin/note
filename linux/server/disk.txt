
 lsblk -d -o name,rota       1是HDD机械硬盘   0是ssd固态硬盘固态硬盘    (应该是的)
 iotop命令可以查看每个进程使用io    用法：iotop -o
 
 延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。所以延迟写机制本身是存在数据丢失的风险的，而异步写机制则不会有这方面的担心。
 自缓存应用程序（ self-caching applications）：应用程序有自己的数据缓存机制（数据库），比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器
 缓存 I/O ：应用程序(用户地址空间)---页缓存(内存)---磁盘    数据拷贝操作所带来的 CPU 以及内存开销是非常大
   标准访问文件的方式：缓存 I/O ， read() 和 write() ，在数据被写到页缓存中的时候，延迟写机制（ deferred writes ）
   同步访问文件的方式：写数据的操作是在数据完全被写回磁盘上才算完成的
   内存映射方式：适合大量数据，内存区域（ memory region ）是可以跟一个普通的文件或者块设备文件的某一个部分关联起来的，若进程要访问内存页中某个字节的数据，操作系统就会将访问该内存区域的操作转换为相应的访问文件的某个字节的操作。Linux 中提供了系统调用 mmap() 来实现(利用 mmap 代替 read)。与标准的访问文件的方式相比，内存映射方式可以减少标准访问文件方式中 read() 系统调用所带来的数据拷贝操作
   直接 I/O 方式:数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输
   直接 I/O 经常需要跟异步 I/O 结合起来使用
 
 文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构，在存储设备上组织文件的方法，操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。
 		具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。
 		超级块superblock,i节点inode,数据块data block，目录块directory block，和间接块indirection block。超级块包括文件系统的总体信息，比如大小（其准确信息依赖文件系统）。i节点包括除了名字外的一个文件的所有信息，名字与i节点数目一起存在目录中，目录条目包括文件名和文件的i节点数目。i节点包括几个数据块的数目，用于存储文件的数据。i节点中只有少量数据块数的空间，
 		如果需要更多，会动态分配指向数据块的指针空间。这些动态分配的块是间接块；为了找到数据块，这名字指出它必须先找到间接块的号码
 SSHD硬盘/HHD混合硬盘：HDD+SSD=SSHD，SSHD硬盘主体是机械硬盘，但是盘体上自带闪存模块，此闪存模块负责的工作是数据的运算处理和数据的传输，这混合硬盘上面配备的闪存模块我们也可以理解为SSD固态硬盘，只是这SSD固态硬盘的容量不大，一般混合硬盘里面的SSD是用来启动操作系统的，混合硬盘里面的SSD模块是存储系统缓存文件的
 HDD硬盘：机械硬盘，机械硬盘是传统的盘片+磁头的工作原理，数据都是存储在盘片上面，磁头在盘片上面“做运动”来读取和处理数据信息
 SSD硬盘：固态硬盘，NVME协议SSD是需要主板支持的(2.5英寸的SATA类型、M2类型的2280、M2类型的2240和M2类型的2242)
 RAID:磁盘阵列
 IDE(Integrated Drive Electronics,集成磁盘电子接口,是一种硬盘的传输接口，另一个名称叫做ATA
 EIDE（Enhanced IDE）还制定了连接光盘等非硬盘产品的标准,又称为ATAPI接口
 Fast ATA是专指硬盘接口
 ATA是Advanced Technology Attachment的缩写。ATA是广为使用的IDE和EIDE设备的相关标准。是计算机上的附加设备。它可以使用户方便地在PC机上连接硬盘。
 SATA是Serial ATA的缩写，即串行ATA。是一种完全不同于并行(PATA)的新型硬盘接口类型，它是采用串行方式进行传输数。S串行接口还具有结构简单、支持热插拔的优点。
 
 disk是可以不分区直接格式化使用的
 ssd固态硬盘分区需要分区对齐，SSD上的分区分割点需对齐SSD block size倍数的状态，不然会影响效率与寿命。分区不对齐，对4KB随机写入的影响最大，性能可能差10倍
 CHS(Cylinder-head-sector)是最早用于访问硬盘的寻址方式。虽然CHS的值现在早已不再与实际的物理值相对应(只是个逻辑值)，但是依然有许多磁盘管理程序(比如fdisk/cfdisk)使用CHS的方式来理解硬盘。
 side/head：硬盘一般是由一片或几片圆形薄膜叠加而成。每个圆形薄膜都有两个"面"(Side)，这两个面都是用来存储数据的。盘面由上而下从"0"开始编号，依次称为0面、1面、2面……由于每个面都专有一个读写磁头，也常用0头(head)、1头……称之。硬盘面数(或头数)，少的只有2面，多的可达数十面。head使用8bit编址，因此最多可以有2**8=256个磁头(0-255)
 track磁道：圆周，读写硬盘时，磁头不动，磁盘是旋转的，则连续写入的数据是排列在一个圆周上的。我们称这样的圆周为一个磁道(Track)。磁头不动，就是在一个磁道上读写；磁头移动，就会在不同磁道上读写。按照CHS寻址规范，由外向内从"0"开始顺序编号。不过其编址时使用的位宽并不是一个定值(取决于不同的规范)，我们姑且可以认为其足够大。
 cylinder：圆柱，各面上磁道号相同的磁道合起来，称为一个柱面(cylinder)。也就是距轴的距离相同的一组track所形成的圆筒
 
 cylinder也是磁盘分区时的最小单位，分区是按磁道和柱面连续分布的(即每个分区，都是粗细连续的一组筒子)，由外向内从"0"开始顺序编号。并且其编址位宽足够大。
 Sector扇区/页：i/o是以扇区为最小单位，磁道被按512或4096字节划分成若干段，每段称为一个扇区(Sector)。一个扇区的大小是固定的512或4096字节，使用6bit编址，所以其最大值是63
 Block块：文件系统的最小存取空间。一个 Block 最多仅能容纳一个文件，可以随意设定，但必须是sector的整数倍。如ext2 fs的block缺省是4k
 
 LBA：48位LBA(Logical Block Address)寻址方式。LBA是非常单纯的一种寻址模式：从0开始编号来定位区块(扇区)，第一区块LBA=0，第二区块LBA=1，依此类推。以每扇区512字节计算，容量上限可达128PB。LBA寻址模式完全屏蔽了硬盘的物理结构，而将其简单的抽象成一维条带，非常便于操作系统的理解。
 SSD不像HDD那样只有读/写两种操作而且还是统一的，SSD有三种操作：读/写/擦除。闪存的读写单位是4KB或8KB大小的页，而且闪存的擦除(又叫编程)操作是按照128或256页大小的块来操作的。
 LBA模式的HDD第一个分区的起始点从63逻辑扇区(63x512B=31.5KB)开始
 闪存是一种非易失性存储器芯片，用于存储和在个人计算机（PC）和数字设备之间传输数据。它具有电子重编程和擦除的能力。它常见于 USB 闪存驱动器，MP3 播放器，数码相机和固态驱动器。
 ssd：多通道的闪存设备也是把数据拆成一个一个的块，需要把分割点设置在"通道数*block-size"整数倍的位置
 
 假定SSD的参数是这样的：每个页的大小是8KB、每256个页组成一个块，那么也就是说我们必须以256*8KB=2097152B=2048KB=2MB为最小单位对其进行分区。也就是说，我们可以通过强制指定fdisk的命令行参数，使每个柱面(cylinder)的大小为2MB即可达到目的(假定每扇区512字节)：
 fdisk -u=cylinders  -H 128 -S 32  /dev/sdx    
 -H 指定磁头数，只能取 1-256 之间的整数。
 -S 指定每磁道扇区数，只能取 1-63 之间的整数。  
 -b 指定扇区的大小，只能取 512/1024/2048/4096 之一。
 注意，经过本人实测，使用大于512的其他值(假定是N)，会导致fdisk只能使用到真实容量的512/N。所以最好不要使用该选项。
 这三个参数值的乘积就是一个逻辑柱面的总大小，也就是最小分割单位了
 第一个分区的起点不能从默认的第一个柱面First cylinder开始，而是要从第2个柱面开始，否则第一个分区有可能依然不会对齐
 fdisk -u=sectors -l /dev/sda  
 ”Start“*“Sector size”=*MB 
 “End+1”*“Sector size”=*MB
 
 硬链接(hard)还是软连接(symbolic)
 
 磁盘阵列	说明
 RAID 0	    数据被平均写到多个磁盘阵列中，写数据和读数据都是并行的，所以磁盘的IOPS可以提高一倍
 RAID 1	    RAID 1的主要作用是能够提高数据的安全性，他将一份数据分别复制到多个磁盘阵列中，并不能提升IOPS，但是相同的数据有多个备份。通常用于对数据安全性较高的场合中
 RAID 5	    这种设计方式是前两种的折中方式，他将数据平均写到所有磁盘阵列总数减一的磁盘中，往另外一个磁盘中写入这份数据的奇偶校验信息。如果其中一个磁盘损坏，可以通过其他磁盘的数据和这个数据的奇偶校验信息来恢复这份数据
 RAID 0+1	如名字一样，就是根据数据的备份情况进行分组，一份数据同时写到多个备份磁盘分组中，同时多个分组也会并行读写
 
 IOPS:Input/Output Operations Per Second，每秒的输入输出量(或读写次数)
 每秒 I/O 吞吐量 = 磁盘写入加上读出的数据的大小＝ IOPS* 平均 I/O SIZE
 
 iostat: iostat 2(秒) 3(次) -k/m(单位)  // -p(指定磁盘)  sda // -N磁盘整列
 Linux 3.10.0-514.el7.x86_64 (localhost.localdomain) 	07/12/2019 	_x86_64_	(40 CPU)-->内核/版本/主机名 /时间/位数/逻辑cpu数
 avg-cpu:  %user   %nice  %system  %iowait  %steal   %idle
 如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU
 Device:   tps该设备每秒的传输次数,“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。  
 kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
  
   -x：   Device:  rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util  
    rrqm/s和wrqm/s(requests merged)：合并，排队i/o每秒合并数量(如果两个IO发生在相邻的数据块时，他们可以合并成1个IO)
    r/s 和 w/s  : 合并后，每秒磁盘需要读写完成的数量
    rsec/s 和 wsec/s ：每秒从设备读取的扇区数量
    avgqu-sz 向设备发出的请求的平均队列长度   avgrq-sz向设备发出的请求的平均大小(以扇区为单位)
    r_await，w_await，await 排队+i/o时间 
    util：使用时间
 
 
 传统的机械硬盘（HDD）运行主要是靠机械驱动头，包括马达、盘片、磁头摇臂等必需的机械部件，它必须在快速旋转的磁盘上移动至访问位置，依靠主轴主机、磁头和磁头臂来找到位置，至少95%的时间都消耗在机械部件的动作上。
 SSD却不同机械构造，无需移动的部件，主要由主控与闪存芯片组成的SSD可以以更快速度和准确性访问驱动器到任何位置。SSD用集成的电路代替了物理旋转磁盘，访问数据的时间及延迟远远超过了机械硬盘。ssd内部的组成部件：主控--闪存--固件算法。
 
 dm是Device Mapper的缩写，个人觉得是逻辑卷LVM
 dmsetup ls[info]                   (253:X)X就是dmX
 ls -l /dev/mapper/                 查看映射
 more /etc/fstab 
 fdisk -l                      
 
 
 sr代表 scsi + rom          #/dev/cdrom 只是一个到sr0的符号链接
 sd代表 scsi + disk
 sg 代表 scsi + generic
 st代表 scsi + tape
 
 挂载光盘：mount -t iso9660 /dev/cdrom /mnt/cdrom/
 
 df -Th[a]  [file/directory/disk/part]  可以查看某文件/目录/磁盘是挂载到哪里(已经挂载的)---du [-sh/ah]  /*查看大小
 /dev/hda1或/dev/sda1表示，并口硬盘为hd(IDE硬盘)，串口硬盘(SATA硬盘)或SCSI硬盘为sd，第三位为该类型设备的顺序号为abc(第几块设备),第四位为该硬盘的分区号1~4
 串口硬盘和并口硬盘主要的区别在于硬盘于主板通信的方式不一样，物理接口不一样。
 lsblk [-f/-p/-h/-S/-m] [device]  查看磁盘整体情况
 fdisk -l
 blkid
 
 
 分区：
 fdisk /dev/sda
 m -- p -- n -- 选格式p(可以空格) -- 选分区1(可以空格) -- 起始(可以空格) -- 结束+size{K,M,G} -- p [--d]
 lsblk -f(切记先查看以前使用什么文件系统的)-- 格式化：mkfs.ext4 /dev/sda1 // mkfs -t xfs /dev/sda1 --  lsblk -f /df -T    
 /etc/fstab：/dev/hda1   /   ext4        defaults   0 0  -- mount -a  --  lsblk
 ！！！格式化文件系统可以加选项-f强制覆盖，但...请谨慎使用
 



