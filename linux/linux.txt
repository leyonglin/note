
消息队列：
	优点：解耦
		  异步
		  削峰
	缺点：可用性低
		  复杂度高
		  一致性，顺序，可靠，重复

通过唯一键和确认和重传保证数据的可靠性和不重复消费

集群，物理主机和虚拟(逻辑)主机

glib是Gtk+库和Gnome的基础库（Unix-like系統下开发图形界面的应用程序的主流开发工具之一）
glibc本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准c库
libc是Linux下的ANSI C函数库(基本的 C 语言函数库)，被glibc取代了
Boost是为C++语言标准库提供扩展的一些C++程序库的总称。Boost库是一个可移植、提供源代码的C++库，作为标准库的后备，是C++标准化进程的开发引擎之一，是为C++语言标准库提供扩展的一些C++程序库的总称


级联：处理多个彼此关联对象情况下,指当主动方对象执行操作时，被关联对象（被动方）是否同步执行同一操作

流：指源源不断的数据，或者说完整的数据是经过数据片组成的，每个数据片都是一个请求

语言的基础是一组记号和一组规则。根据规则由记号构成的记号串的总体就是语言
PHP专门用来显示网页；Perl更适合文本处理；C语言被广泛用于操作系统和编译器（所谓的系统编程）的开发

硬件--驱动程序--内核--接口库--程序(shell)
内核是程序与硬件的交互层
shell是人与程序的交互层

Shell俗称壳（用来区别于核）:是指“为使用者提供操作界面”的软件（命令解析器）
交互式shell：交互式解释和执行用户输入的命令
非交互式shell：自动地解释和执行预先设定好的一连串的命令

进程通信： 
	每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核
	#在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

内存分为用户空间和内核空间		
进程会调用内核空间接口去磁盘读取数据
磁盘数据拷贝到内核空间，内核空间再拷贝到用户空间	

计算机不能直接理解任何除机器语言以外的语言，因此需要翻译器
	翻译器有两种：
		1.编译：代码执行之前进行编译，生成中间代码文件  
		2.解释：运行时逐行即时编译并立即执行
标识符：开发人员为变量，属性，函数，参数取的名字
关键字：程序本身使用了的词
保留字：预留的"关键字"
表达式：由值，运算符，变量等以能求得数值的有意义排列方法所得的组合，一定有返回值，具有可赋值性
#条件表达式  算术表达式
对象是一个具体的事物，是一组无序的相关属性和方法的集合,是键值对

虚拟地址：操作系统里面，程序的内存地址并不是物理地址，而且通过一个基址+偏移量的方式的计算得到的


高阶函数：一个函数传递的参数或函数return的是函数
闭包：有权访问另一个函数作用域(scope)的变量的函数
	作用：延伸了变量的作用范围
递归：一个函数在内部调用其本身，要有结束条件


类class --> 人类
self --> 某人
对象 --> 唯一人名

 dict['Name']  --> 键值对:形式存储
 a.biabliang   --> 赋值型=存储



Linux Standard Base (LSB)等标准来规范开发者，以及目录架构的File system Hierarchy Standard (FHS)标准规范
Kernel + Softwares + Tools的可完全安装，我们称之为Linux distributio
Open Source (开放源码)的代表授权为GNU的GPL授权及BSD等等
POSIX是可携式操作系统接口(Portable Operating System Interface)的缩写，重点在规范核心与应用程序之间的接口


IDE硬盘机	/dev/hd[a-d]
SCSI/SATA/U盘硬盘机	/dev/sd[a-p]
鼠标	U盘: /dev/usb/mouse[0-15]
当前CDROM/DVDROM	/dev/cdrom
当前的鼠标	/dev/mouse

物理终端：直接连接在主机上的Keyboard键盘，video显示器，mouse鼠标统称
虚拟终端（tty）：附加在物理终端之上，用软件方式虚拟实现
pts(pseudo-terminal slave)是pty的实现方法。

BIOS：启动主动运行的韧体，会认识第一个可启动的装置；
MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；
启动管理程序(boot loader)：一支可读取核心(grub)文件来运行的软件(linux/windows)；
核心文件：开始操作系统的功能...
由上面的说明我们会知道，BIOS与MBR都是硬件本身会支持的功能，至於Boot loader则是操作系统安装在MBR上面的一套软件了。由於MBR仅有446 bytes而已，因此这个启动管理程序是非常小而美的。 这个boot loader的主要任务有底下这些项目：

提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能！
加载核心文件：直接指向可启动的程序区段来开始操作系统；
转交其他loader：将启动管理功能转交给其他loader负责。

Linux distributions大多使用grub管理程序，必须要将他安装到MBR(boot sector)里面才行

GNOME(X windows)  kde

man 1, 5, 8这三个号码特别重要
man man			#关键词的详细说明
whatis cat		#关键词的大概说明
apropos cat     #关于目标单词的说明，单词要尽可能准确
info info	    #关键词的主要说明


umask -S   #创建一般文件后的权限
	新建文件：666-022=644；
	新建目录：777-022=755.
pwd -P(显示实际路径)
cat  -A(显示特殊字符) -n
mkdir -p  -m(带权限)
rmdir 
cp -p(复制属性) -r(递归) -i
mv -i
basename  dirname
cat /etc/man.config | col -x | cat -A   #将tab(^I)转换成空格
cmd | expand -t 6 -   #将tab变成6个空格
join [-a1](左连接) [-a2](右连接) [-o 1.1/1.2..](文件.栏位) [-t ":"分隔符] file1 file2   找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备
paste /etc/passwd /etc/shadow  #将两个文件合并在一起
split [-bl] file PREFIX
	-b  ：后面可接欲分割成的文件大小，可加单位，例如 b, k, m 等；
	-l  ：以行数来进行分割。
	PREFIX ：代表前导符的意思，可作为分割文件的前导文字（名称）。


whereis which locate locale

stat
ls -lc filename         列出文件的 ctime
ls -lu filename         列出文件的 atime
ls -l filename          列出文件的 mtime


find   被攻击的时候可以看创建了什么文件
find / -max[min]depth 5 -user nobody -name test.txt -size +100k -mtime +4/4 -type s -perm +7000 -exec ls -l {} \;   
	 -empty           #空文件/目录  
	 ! -name "*.log"  #排除文件  
	 -mmin -30        #三十分钟内
	 -nouser          #查无有效属主的文件，即文件的属主在/etc/passwd中不存在
     -newer   f1 !f2  #查更改时间比f1新但比f2旧的文件
	 -follow          #如果遇到符号链接文件，就跟踪链接所指的文件
	 #-prune           #忽略某个目录
    find ./ ! \( −path ′/proc*′ −o −path ′/sys*′ \) -a -name '*.txt' -print  #在除dir0、dir1及子目录以外的目录下查找txt后缀文件
    find ./   \( −path ′./dir0*′ −o −path ′./dir1*′ \) -a -name '*.txt' -print  #在dir0、dir1及子目录下查找txt后缀文件
#注意，1.任何使用时间的选项，都有 /-/+   2.使用()要转义，并且前后要有空格  3.使用-path，一定要在路径后面加* ，这才表示在这个路径之后都不匹配  
find正则表达式由于-name参数只支持“*”、“?”、“[]”这三个通配符（.代表的就是普通的.而已）
	find . -name '*a1*txt'（*代表可有可无）   //   find ./  -name '[a-z]*'（匹配小写开头）  //  find ./  -name '??' （匹配两个字符） // find . -name "*[1|2]"  //  find . -name "*[0-3]"

xargs: -t在执行前回显cmd  -p交互  -d(把...当作分割符)  -n3三行一组  -0
cat /etc/passwd | xargs -d ':'  echo
ls | xargs ls -l			#默认带一个参数
ls | xargs -i mv {} {}.txt  #-i与{}搭配，即需要两个参数的时候
cat arg.txt | xargs -I {} echo -p {} -l   		#管道左边输出等于-I右边的{}，然后传递给第二个{}
find . -type f | xargs -I {}.t  cp {}.t {}.txt	#管道左边的输出等于{}.t传递给后面的两个{}.t
find . -name "*.txt" -print0 | xargs -0 rm      #find -print0表示在find的每一个结果之后加一个NULL字符，而不是默认加一个换行符。find的默认在每一个结果后加一个'\n'，所以输出结果是一行一行的。当使用了-print0之后，就变成一行了，然后xargs -0表示xargs用NULL来作为分隔符。这样前后搭配就不会出现空格和换行符的错误了。选择NULL做分隔符，是因为一般编程语言把NULL作为字符串结束的标志，所以文件名不可能以NULL结尾，这样确保万无一失。
ls | awk -F'.' '{print $1}'|xargs -i mv {}.bak {} #删除文件后缀


单纯的 tar 功能仅是『打包』而已，亦即是将很多文件集结成为一个文件
tar -tf /root/etc.tar.gz                   #查看
tar -xvf /root/etc.tar.gz etc/shadow    #解压单个文件
tar -cavf /root/etc.tar.gz  /root/etc      #压缩  
tar -caPf ${backup_dir}/data_views_nginx_`date +%Y%m%d%H%M`.tar.gz  cms_9001/views/  \      #这里是 \[Enter] 
    -C /opt/apps/nginx/ conf --exclude "Geo*"  #-P压缩绝对路径(可以tf查看),日志结尾加时间戳，-C切换路径，这样或备份在同一级目录下(后面写绝对路径也可以，备份会加上路径)，排除Geo文件
  --newer-mtime=DATE   #仅备份比给定时间之后更新的
tar -cavf - /etc | tar -xvf -   #在管线命令当中，常常会使用到前一个命令的 stdout 作为这次的 stdin，将/etc下的文件压缩拷贝到当前目录下
tar -czf - ./down/ | pv   > down2.tgz    #压缩

dump：完整/增量备份文件系统
restore：恢复 
	restore -i -f /root/etc.dump      #交互恢复


编码转换：
	unix2doc	
	iconv -f 原本编码 -t 新编码 filename [-o newfile]	 #跟多
	
只要能够操作应用程序的接口都能够称为壳程序
shell有多种：bash是其中一个	
type

unset myname
env：环境变量       #export自定义变量转成环境变量
set：本地变量
	global
	local
read
array 
declare / typeset :宣告变量的类型 (1.sum=100+300+50  2.declare -i sum=100+300+50  echo $sum)
	 declare -r sum(设置只读，不能修改和取消，还有别的选项)
ulimit -a

stty -a   # 可以设置热键  stty erase ^h 
set [-uvCHhmBx]
	-x  ：默认不激活。若激活后，在命令被运行前，会显示实际命令内容(前面有 ++ 符号)
	-v  ：默认不激活。若激活后，在信息被输出前，会先显示信息的原始内容
	-e  : 执行的时候如果出现了返回值为非零，整个脚本(终端)就会立即退出 
	-n  ：只读取指令，而不实际执行
	-t  ：执行完随后的指令，即退出shell
	-u  ：默认不激活。若激活后，当使用未配置变量时，会显示错误信息；
	-h  ：默认激活。与历史命令有关；
	-H  ：默认激活。与历史命令有关；
	-m  ：默认激活。与工作管理有关；
	-B  ：默认激活。与刮号 [] 的作用有关；
	-C  ：默认不激活。若使用 > 等，则若文件存在时，该文件不会被覆盖。


--help
batch：系统有空时才进行背景任务，调用 at 来进行命令的下达
at ：at 是个可以处理仅运行一次就结束排程的命令（服务：atd）   权限：/etc/at.allow 或者 /etc/at.allow
crontab ：crontab 这个命令所配置的工作将会循环的一直进行下去  权限：/etc/cron.allow 或者 /etc/cron.deny   配置文件/etc/cron*
	*(星号)  ,(逗号)  -(减号)  /n(斜线)
anacron 其实也是透过 crontab 来运行 ：可唤醒停机期间的工作任务，以天为单位或者是在启动后立刻进行 anacron 的动作   配置文件：/etc/anacrontab

	
/var/log/secure, /var/log/messages

wall "I will shutdown my linux server..."  #广播


触发任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 ID ，称为 PID，同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限配置

程序是指令的集合，是进程运行的静态描述文本，而进程则是程序在系统上顺序执行时的动态活动

在 Linux 的程序呼叫通常称为 fork-and-exec 的流程，程序都会藉由父程序以复制 (fork) 的方式产生一个一模一样的子程序， 然后被复制出来的子程序再以 exec 的方式来运行实际要进行的程序，最终就成为一个子程序的存在
exec：在当前bash下fork出一个bash运行程序，执行完成后退出


&   jobs -l     bg   fg   ctrl+z
 nohup [命令与参数] &


root 可随意调整自己或他人程序的 Nice 值，且范围为 -20 ~ 19 ；
一般使用者仅可调整自己程序的 Nice 值，且范围仅为 0 ~ 19 (避免一般用户抢占系统资源)；
一开始运行程序就立即给予一个特定的 nice 值：用 nice 命令；
	nice [-n 数字] command
调整某个已经存在的 PID 的 nice 值：用 renice 命令。
	renice [number] PID


找出进程pid
	pidof CMD

/etc/init.d/* ：启动脚本放置处
	系统上几乎所有的服务启动脚本都放置在这里！事实上这是公认的目录，我们的 CentOS 实际上放置在 /etc/rc.d/init.d/ 啦！ 不过还是有配置连结档到 /etc/init.d/ 的！既然这是公认的目录，因此建议您记忆这个目录即可！
/etc/sysconfig/* ：各服务的初始化环境配置文件
	几乎所有的服务都会将初始化的一些选项配置写入到这个目录下，举例来说，登录档的 syslog 这支 daemon 的初始化配置就写入在 /etc/sysconfig/syslog 这里呢！而网络的配置则写在 /etc/sysconfig/network 这个文件中。 所以，这个目录内的文件也是挺重要的；
/etc/xinetd.conf, /etc/xinetd.d/* ：super daemon 配置文件
	super daemon 的主要配置文件 (其实是默认值) 为 /etc/xinetd.conf ，不过我们上面就谈到了， super daemon 只是一个统一管理的机制，他所管理的其他 daemon 的配置则写在 /etc/xinetd.d/* 里头喔！
/etc/* ：各服务各自的配置文件
/var/lib/* ：各服务产生的数据库
	一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。举例来说，数据库管理系统 MySQL 的数据库默认就是写入 /var/lib/mysql/ 这个目录下啦！
/usr/lib64：函数库
/var/run/* ：各服务的程序之 PID 记录处
	为了担心管理时影响到其他的程序， 因此 daemon 通常会将自己的 PID 记录一份到 /var/run/ 当中！例如登录文件的 PID 就记录在 /var/run/syslogd.pid 这个文件中。如此一来， /etc/init.d/syslog 就能够简单的管理自己的程序啰。


/etc/hosts.allow 与 /etc/hosts.deny   #顺序读取，ldd   有没有支持libwrap.so 那个函式库
	<service(program_name)> : <IP, domain, hostname> : <action>
	rsync : 127.0.0.100 127.0.0.200 [: deny]

yum -y install tcp_wrappers
	spawn (action)
	可以利用后续接的 shell 来进行额外的工作，且具有变量功能，主要的变量内容为： %h (hostname), %a (address), %d (daemon)等等；
	twist (action)
	立刻以后续的命令进行，且运行完后终止该次联机的要求 (DENY)

rsyslog配置文件：/etc/rsyslog.conf


    加载 BIOS 的硬件资讯与进行自我测试，并依据配置取得第一个可启动的装置；
    读取并运行第一个启动装置内 MBR 的 boot Loader (亦即是 grub, spfdisk 等程序)；
		提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能！
		加载核心文件：直接指向可启动的程序区段来开始操作系统；
		转交其他 loader：将启动管理功能转交给其他 loader 负责
    依据 boot loader 的配置加载 Kernel ，Kernel 会开始侦测硬件与加载驱动程序；
    在硬件驱动成功后，Kernel 会主动呼叫 init 程序，而 init 会取得 run-level 资讯；
    init 运行 /etc/rc.d/rc.sysinit 文件来准备软件运行的作业环境 (如网络、时区等)；#调用/etc/init.d/
    init 运行 run-level 的各个服务之启动 (script 方式)；
    init 运行 /etc/rc.d/rc.local 文件；自定义自启脚本
    init 运行终端机模拟程序 mingetty 来启动 login 程序，最后就等待使用者登陆啦；


.configure：侦测程序来侦测checking使用者的作业环境， 以及该作业环境是否有软件开发商所需要的其他功能,生成Makefile文件(记录了原始码如何编译的详细资讯)，nginx编译时的configure是shell文件
make: 依据Makefile编译成可执行文件(gcc命令的集合)
make install：依据Makefile移动到指定路径(nginx是创建目录mkdir及复制cp文件到对应目录)



ldd 命令
ldd -v 函数库  #查看依赖
ldd --version  #查看glibc版本
静态函式库:扩展名为 .a     编译的时候会直接整合到运行程序当中，所以利用静态函式库编译成的文件会比较大一些   运行档可以独立运行，但因为函式库是直接整合到运行档中， 因此若函式库升级时，整个运行档必须要重新编译才能将新版的函式库整合到程序当中
动态函式库:扩展名为 .so    在程序里面只有一个『指向 (Pointer)』的位置而已
将动态函式库加载高速缓存:  在 /etc/ld.so.conf 里面写下想要读入高速缓存当中的动态函式库所在的目录(是目录)
ldconfig  #将/etc/ld.so.conf 中动态函式库所在的目录下动态函数库加载到cache中
ldconfig -p   #查看
#.o文件是源码编译出的二进制文件，一个.c或.cpp文件对应一个.o文件。.h是C语言的全局声明文件


签名验证：md5sum / sha1sum  ： MD5 与 SHA1 加密机制（用法是一样的）


*.src.rpm: 这种安装后是一个源码包，再包装成rpm包(制作rpm包)
rpmbuild -ba xxx.spec  <==编译并同时产生RPM与SRPM文件
rpmbuild -bb xxx.spec  <==仅编译成 RPM 文件



平台名称	适合平台说明(硬件方面都可以向下兼容的)
i386		几乎适用於所有的 x86 平台，不论是旧的 pentum 或者是新的 Intel Core 2 与 K8 系列的 CPU 等等，都可以正常的工作！那个 i 指的是 Intel 兼容的 CPU 的意思，至於 386 不用说，就是 CPU 的等级啦！
i586		就是针对 586 等级的计算机进行最佳化编译。那是哪些 CPU 呢？包括 pentum 第一代 MMX CPU， AMD 的 K5, K6 系列 CPU (socket 7 插脚) 等等的 CPU 都算是这个等级；
i686		在 pentun II 以后的 Intel 系列 CPU ，及 K7 以后等级的 CPU 都属於这个 686 等级！ 由於目前市面上几乎仅剩 P-II 以后等级的硬件平台，因此很多 distributions 都直接释出这种等级的 RPM 文件。
x86_64		针对 64 位的 CPU 进行最佳化编译配置，包括 Intel 的 Core 2 以上等级 CPU ，以及 AMD 的 Athlon64 以后等级的 CPU ，都属於这一类型的硬件平台。
noarch		就是没有任何硬件等级上的限制。一般来说，这种类型的 RPM 文件，里面应该没有 binary program 存在， 较常出现的就是属於 shell script 方面的软件。

Alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。
Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。
RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。
GA:General Availability,正式发布的版本，在国外都是用GA来说明release版本的。
α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；
β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；
λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。

rpm：
--replacefiles 	使用时机： 如果在安装的过程当中出现了『某个文件已经被安装在你的系统上面』的资讯，又或许出现版本不合的信息 (confilcting files) 时，可以使用这个参数来直接覆盖文件。危险性： 覆盖的动作是无法复原的！所以，你必须要很清楚的知道被覆盖的文件是真的可以被覆盖喔！否则会欲哭无泪！
--test 	使用时机： 想要测试一下该软件是否可以被安装到使用者的 Linux 环境当中，可找出是否有属性相依的问题。范例为：
	rpm -ivh pkgname.i386.rpm --test
--justdb 	使用时机： 由於 RPM 数据库破损或者是某些缘故产生错误时，可使用这个选项来升级软件在数据库内的相关资讯。
--nosignature 	使用时机： 想要略过数码签章的检查时
--noscripts 	使用时机：不想让该软件在安装过程中自行运行某些系统命令。说明： RPM 的优点除了可以将文件放置到定位之外，还可以自动运行一些前置作业的命令，例如数据库的初始化。 如果你不想要让 RPM 帮你自动运行这一类型的命令，就加上他吧！
--prefix 新路径 	使用时机： 要将软件安装到其他非正规目录时。举例来说，你想要将某软件安装到 /usr/local 而非正规的 /bin, /etc 等目录， 就可以使用『 --prefix /usr/local 』来处理了
-Uvh 	后面接的软件即使没有安装过，则系统将予以直接安装； 若后面接的软件有安装过旧版，则系统自动升级至新版；
-Fvh 	如果后面接的软件并未安装到你的 Linux 系统上，则该软件不会被安装；亦即只有已安装至你 Linux 系统内的软件会被『升级』！

-q  ：仅查询，后面接的软件名称是否有安装；
-qa ：列出所有的，已经安装在本机 Linux 系统上面的所有软件名称；
-qi ：列出该软件的详细资讯 (information)，包含开发商、版本与说明等；
-ql ：列出该软件所有的文件与目录所在完整档名 (list)；
-qc ：列出该软件的所有配置档 (找出在 /etc/ 底下的档名而已)
-qd ：列出该软件的所有说明档 (找出与 man 有关的文件而已)
-qR ：列出与该软件有关的相依赖软件所含的文件 (Required 的意思)
-qf ：由后面接的文件名称，找出该文件属於哪一个已安装的软件；
查询某个 RPM 文件内含有的资讯：
-qp[icdlR]：注意 -qp 后面接的所有参数以上面的说明一致。但用途仅在於找出
	    某个 RPM 文件内的资讯

#rpm -Va logrotate       列出目前系统上面所有可能被更动过的文件；
#rpm -Vf /etc/crontab    是否有被更动过

rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5    #导入验证数据

rpm --rebuilddb   <==重建数据库


yum:
	-y ：当 yum 要等待使用者输入时，这个选项可以自动提供 yes 的回应；
	--installroot=/some/path ：将该软件安装在 /some/path 而不使用默认路径[查询工作项目]
	search  ：搜寻某个软件名称或者是描述 (description) 的重要关键字；
	list    ：列出目前 yum 所管理的所有的软件名称与版本，有点类似 rpm -qa；
	info    ：同上，不过有点类似 rpm -qai 的运行结果；
	provides：从文件去搜寻软件！类似 rpm -qf 的功能！


yum grouplist/groupinfo


核心模块：/lib/modules/$(uname -r)/kernel/ 
核心(内核)是直接被读入到主内存当中的



VNC的服务端目的是分享其所运行机器的屏幕， 服务端被动的允许客户端控制它。 VNC客户端（或Viewer） 观察控制服务端，与服务端交互。 VNC 协议 Protocol (RFB)是一个简单的协议，传送服务端的原始图像到客户端（一个X,Y 位置上的正方形的点阵数据）
	无法传输文件
RDP文件传输协议:RDP远程协议是一个多通道协议，让用户通过本地电脑连接远程服务器。大部分的Windows、Linux服务器都有相应的客户端
计算机与通信：C&C
客户-服务器方式（C/S方式）和对等连接方式（P2P方式）
链路（link）：从一个结点到另一个结点的一段物理线路。中间没有任何其他交点
ISP（Internet Service Provider）：因特网服务提供者（提供商）
数据链路（data link）：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路
数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议
网络层(networ0-k layer)负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送，网络层的另一个任务就是选择合适的路由
NIC（Network Interface Card，网络适配器，即网卡）
IP 间的通信依赖 MAC 地址

网关是转发其他服务器通信数据的服务器(nginx),可以连接非http服务(mysql)【存储节点？】
代理是一种有转发功能的应用程序，它扮演了位于服务器和客户 端“中间人”的角色(cdn,连接http服务器)via字段
隧道的目的是确保客户端能与服务器进行安全的 通信。 隧道本身不会去解析 HTTP 请求
缓存分服务器和客户端缓存
WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准，发起方仍是客户端
WebDAV（put方式）是一个可对 Web 服务器上的内容直接进 行文件复制、编辑等操作的分布式文件系统
CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在 接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的 作用下，程序会对请求内容做出相应的动作，每次接到请求，程序都要跟着启动一次。
Servlet 运行 在与 Web 服务器相同的进程中，因此受到的负载较小



三次握手：
  接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了
  双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证

TCP 协议如何保证可靠传输
	应用数据被分割成 TCP 认为最适合发送的数据块。
	TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
	校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
	TCP 的接收端会丢弃重复的数据。
	流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制，流量控制是为了控制发送方发送速率，保证接收方来得及接收。）
	拥塞控制： 当网络拥塞时，减少数据的发送，为了防止过多的数据注入到网络中。TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。
	停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。



掩码位26，则26-24=2(1表示netid和subnetid , 0表示hostid)  总共为128+64+64，因此ip数量是0-63(可用主机地址：1-62)  64-127 ...
1.按子网数量分，即网络位，所以是从左往右
  将B类IP地址168.195.0.0划分成27个子网：27=11011；
  该二进制为五位数，N = 5 （16 <27< 32因此只能划分出32个子网）
  将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0
2.按主机数量分，即主机位，所以是从右往左分
  将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台
  700=1010111100(这个局域网最多有2^10=1024个ip，分去700个，剩下的可以使用别的掩码进行分配，不会浪费)
  11111111.11111111.11111100.00000000，即255.255.252.0(22掩码)
3.
  一个子网有10台主机，那么这个子网需要的IP地址: 10＋1＋1＋1＝13 （第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址）
  13小于16（16等于2的4次方）所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240
  如果一个子网有14台主机，14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224
4.
  28掩码(24-32范围内对最后一位十进制起作用 32-28=4，按16地址)： 
  10.0.0.0    网络：0   可用ip范围：1-14    广播：15(2^(32-28)-1)    #总共2^4=16个IP
  10.0.0.16   网络：16  可用ip范围：17-30   广播：31(2^(32-28)-1+16) #总共2^4=16个IP
  192.167.0.0/13(9-16范围内对第二位十进制起作用16-13=3)  9<12<16   是对第二个十进制进行运算(16-13=3 则第二位十进制数量位按2^3=8递增)  2^3*20 <167< 2^3*21   所以第二位十进制范围为160-167，
		  因此网络：192.160.0.0  可用IP范围：192.160.0.1~192.167.255.254   广播地址：192.167.255.255
最小的ip子网：255.255.255.252(如果是31不能表示位一个子网，因为没可用的主机地址。32表示主机的掩码，不是表示一个网络) (31和32没有网络地址和广播地址)



符合REST设计风格的Web API称为RESTful API。
#目的是便于不同软件/程序在网络（例如互联网）中互相传递信息，允许客户端发出以统一资源标识符访问和操作网络资源的请求
它从以下三个方面资源进行定义：
    直观简短的资源地址：URI，比如：http://example.com/resources。
    传输的资源：Web服务接受与返回的互联网媒体类型，比如：JSON，XML，YAML等。
    对资源的操作：Web服务在该资源上所支持的一系列请求方法（比如：POST，GET，PUT或DELETE）









