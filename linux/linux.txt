
Linux Standard Base (LSB)等标准来规范开发者，以及目录架构的File system Hierarchy Standard (FHS)标准规范
Kernel + Softwares + Tools的可完全安装，我们称之为Linux distributio
Open Source (开放源码)的代表授权为GNU的GPL授权及BSD等等
POSIX是可携式操作系统接口(Portable Operating System Interface)的缩写，重点在规范核心与应用程序之间的接口


IDE硬盘机	/dev/hd[a-d]
SCSI/SATA/U盘硬盘机	/dev/sd[a-p]
鼠标	U盘: /dev/usb/mouse[0-15]
当前CDROM/DVDROM	/dev/cdrom
当前的鼠标	/dev/mouse


BIOS：启动主动运行的韧体，会认识第一个可启动的装置；
MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；
启动管理程序(boot loader)：一支可读取核心(grub)文件来运行的软件(linux/windows)；
核心文件：开始操作系统的功能...
由上面的说明我们会知道，BIOS与MBR都是硬件本身会支持的功能，至於Boot loader则是操作系统安装在MBR上面的一套软件了。由於MBR仅有446 bytes而已，因此这个启动管理程序是非常小而美的。 这个boot loader的主要任务有底下这些项目：

提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能！
加载核心文件：直接指向可启动的程序区段来开始操作系统；
转交其他loader：将启动管理功能转交给其他loader负责。

Linux distributions大多使用grub管理程序，必须要将他安装到MBR(boot sector)里面才行

GNOME(X windows)  kde

man 1, 5, 8这三个号码特别重要
man man
whatis cat
apropos cat
info info


umask -S   #创建一般文件后的权限
pwd -P(显示实际路径)
cat  -A(显示特殊字符) -n
mkdir -p  -m(带权限)
rmdir 
cp -p(复制属性) -r(递归) -i
mv -i
basename  dirname
cat /etc/man.config | col -x | cat -A   #将tab(^I)转换成空格
cmd | expand -t 6 -   #将tab变成6个空格
join [-a1](左连接) [-a2](右连接) [-o 1.1/1.2..](文件.栏位) [-t ":"分隔符] file1 file2   找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备
paste /etc/passwd /etc/shadow  #将两个文件合并在一起
split [-bl] file PREFIX
	-b  ：后面可接欲分割成的文件大小，可加单位，例如 b, k, m 等；
	-l  ：以行数来进行分割。
	PREFIX ：代表前导符的意思，可作为分割文件的前导文字（名称）。
xargs

whereis which locate locale

stat
ls -lc filename         列出文件的 ctime
ls -lu filename         列出文件的 atime
ls -l filename          列出文件的 mtime


find   被攻击的时候可以看创建了什么文件
find / -u nobody -name test.txt -size +100k -depth 5 -mtime +4/4 -type s -perm +7000 -exec ls -l {} \;   
	 -empty           #空文件/目录  
	 ! -name "*.log"  #排除文件  
	 -mmin -30        #三十分钟内
	 -nouser          #查无有效属主的文件，即文件的属主在/etc/passwd中不存
     -newer   f1 !f2  #查更改时间比f1新但比f2旧的文件
	 -follow          #如果遇到符号链接文件，就跟踪链接所指的文件
	 -prune           #忽略某个目录
    find ./ ! \( −path ′/proc*′ −o −path ′/sys*′ \) -a -name '*.txt' -print  #在除dir0、dir1及子目录以外的目录下查找txt后缀文件
    find ./   \( −path ′./dir0*′ −o −path ′./dir1*′ \) -a -name '*.txt' -print  #在dir0、dir1及子目录下查找txt后缀文件
	#注意，1.使用()要转义，并且前后要有空格  2.使用-path，一定要在路径后面加* ，这才表示在这个路径之后都不匹配


xargs: -d分割符  -p交互  -t在执行前回显cmd
ls | xargs -i mv {} {}.txt  #-i与{}搭配


单纯的 tar 功能仅是『打包』而已，亦即是将很多文件集结成为一个文件
tar -tf /root/etc.tar.gz                   #查看
tar -jxv -f /root/etc.tar.gz etc/shadow    #解压单个文件
tar -cavf /root/etc.tar.gz  /root/etc      #压缩  
tar -caPf ${backup_dir}/data_views_nginx_`date +%Y%m%d%H%M`.tar.gz  cms_9001/views/  \      #这里是 \[Enter] 
    -C /opt/apps/nginx/ conf --exclude "Geo*"  #-P压缩绝对路径(可以tf查看),日志结尾加时间戳，-C切换路径，这样或备份在同一级目录下(后面写绝对路径也可以，备份会加上路径)，排除Geo文件
  --newer-mtime=DATE   #仅备份比给定时间之后更新的
tar -cavf - /etc | tar -xvf -   #在管线命令当中，常常会使用到前一个命令的 stdout 作为这次的 stdin，将/etc下的文件压缩拷贝到当前目录下


dump：完整/增量备份文件系统
restore：恢复 
	restore -i -f /root/etc.dump      #交互恢复


编码转换：
	unix2doc	
	iconv -f 原本编码 -t 新编码 filename [-o newfile]	 #跟多
	
只要能够操作应用程序的接口都能够称为壳程序
shell有多种：bash是其中一个	
type

unset myname
env：环境变量       #export自定义变量转成环境变量
set：本地变量
	global
	local
read
array 
declare / typeset :宣告变量的类型 (1.sum=100+300+50  2.declare -i sum=100+300+50  echo $sum)
	 declare -r sum(设置只读，不能修改和取消，还有别的选项)
ulimit -a

stty -a   # 可以设置热键  stty erase ^h 
set [-uvCHhmBx]
	-u  ：默认不激活。若激活后，当使用未配置变量时，会显示错误信息；
	-v  ：默认不激活。若激活后，在信息被输出前，会先显示信息的原始内容；
	-x  ：默认不激活。若激活后，在命令被运行前，会显示实际命令内容(前面有 ++ 符号)
	-e  : 执行的时候如果出现了返回值为非零，整个脚本(终端)就会立即退出 
	-n 　只读取指令，而不实际执行。
	-t 　执行完随后的指令，即退出shell
	-h  ：默认激活。与历史命令有关；
	-H  ：默认激活。与历史命令有关；
	-m  ：默认激活。与工作管理有关；
	-B  ：默认激活。与刮号 [] 的作用有关；
	-C  ：默认不激活。若使用 > 等，则若文件存在时，该文件不会被覆盖。

cat <<eof>>test
HISTFILE=/var/history/$USER-$UID.log
HISTSIZE=1000
HISTFILESIZE=5000
HISTIGNORE=”pwd:ls:ls -ltr:”
HISTTIMEFORMAT="%F %T "
HISTCONTROL = ignorespace              #第一个字符为空格的时候，不会被记录到history
HISTCONTROL=ignoredups				   #过滤相邻相同命令
shopt -s histappend					   #多个终端共享history，实时追加；	
readonly PROMPT_COMMAND="history -a"   #这个意味着，每次执行命令都会在结束后执行"history -a"
eof									   #readonly显示只读变量，readonly 变量  #定义只读变量						  
history -c       #临时清理history（包括家目录下的history）
history -d num #删除指定history



--help
batch：系统有空时才进行背景任务，调用 at 来进行命令的下达
at ：at 是个可以处理仅运行一次就结束排程的命令（服务：atd）   权限：/etc/at.allow 或者 /etc/at.allow
crontab ：crontab 这个命令所配置的工作将会循环的一直进行下去  权限：/etc/cron.allow 或者 /etc/cron.deny   配置文件/etc/cron*
	*(星号)  ,(逗号)  -(减号)  /n(斜线)
anacron 其实也是透过 crontab 来运行 ：可唤醒停机期间的工作任务，以天为单位或者是在启动后立刻进行 anacron 的动作   配置文件：/etc/anacrontab

	
/var/log/secure, /var/log/messages

wall "I will shutdown my linux server..."  #广播


触发任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 ID ，称为 PID，同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限配置

程序是指令的集合，是进程运行的静态描述文本，而进程则是程序在系统上顺序执行时的动态活动

在 Linux 的程序呼叫通常称为 fork-and-exec 的流程 (注1)！程序都会藉由父程序以复制 (fork) 的方式产生一个一模一样的子程序， 然后被复制出来的子程序再以 exec 的方式来运行实际要进行的程序，最终就成为一个子程序的存在
exec：在当前bash下fork出一个bash运行程序，执行完成后退出


&   jobs -l     bg   fg   ctrl+z
 nohup [命令与参数] &


root 可随意调整自己或他人程序的 Nice 值，且范围为 -20 ~ 19 ；
一般使用者仅可调整自己程序的 Nice 值，且范围仅为 0 ~ 19 (避免一般用户抢占系统资源)；
一开始运行程序就立即给予一个特定的 nice 值：用 nice 命令；
	nice [-n 数字] command
调整某个已经存在的 PID 的 nice 值：用 renice 命令。
	renice [number] PID


找出进程pid
	pidof init

/etc/init.d/* ：启动脚本放置处
	系统上几乎所有的服务启动脚本都放置在这里！事实上这是公认的目录，我们的 CentOS 实际上放置在 /etc/rc.d/init.d/ 啦！ 不过还是有配置连结档到 /etc/init.d/ 的！既然这是公认的目录，因此建议您记忆这个目录即可！
/etc/sysconfig/* ：各服务的初始化环境配置文件
	几乎所有的服务都会将初始化的一些选项配置写入到这个目录下，举例来说，登录档的 syslog 这支 daemon 的初始化配置就写入在 /etc/sysconfig/syslog 这里呢！而网络的配置则写在 /etc/sysconfig/network 这个文件中。 所以，这个目录内的文件也是挺重要的；
/etc/xinetd.conf, /etc/xinetd.d/* ：super daemon 配置文件
	super daemon 的主要配置文件 (其实是默认值) 为 /etc/xinetd.conf ，不过我们上面就谈到了， super daemon 只是一个统一管理的机制，他所管理的其他 daemon 的配置则写在 /etc/xinetd.d/* 里头喔！
/etc/* ：各服务各自的配置文件
/var/lib/* ：各服务产生的数据库
	一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。举例来说，数据库管理系统 MySQL 的数据库默认就是写入 /var/lib/mysql/ 这个目录下啦！
/usr/lib64：函数库
/var/run/* ：各服务的程序之 PID 记录处
	为了担心管理时影响到其他的程序， 因此 daemon 通常会将自己的 PID 记录一份到 /var/run/ 当中！例如登录文件的 PID 就记录在 /var/run/syslogd.pid 这个文件中。如此一来， /etc/init.d/syslog 就能够简单的管理自己的程序啰。


/etc/hosts.allow 与 /etc/hosts.deny   #顺序读取，ldd   有没有支持libwrap.so 那个函式库
	<service(program_name)> : <IP, domain, hostname> : <action>
	rsync : 127.0.0.100 127.0.0.200 [: deny]

yum -y install tcp_wrappers
	spawn (action)
	可以利用后续接的 shell 来进行额外的工作，且具有变量功能，主要的变量内容为： %h (hostname), %a (address), %d (daemon)等等；
	twist (action)
	立刻以后续的命令进行，且运行完后终止该次联机的要求 (DENY)

rsyslog配置文件：/etc/rsyslog.conf


    加载 BIOS 的硬件资讯与进行自我测试，并依据配置取得第一个可启动的装置；
    读取并运行第一个启动装置内 MBR 的 boot Loader (亦即是 grub, spfdisk 等程序)；
		提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能！
		加载核心文件：直接指向可启动的程序区段来开始操作系统；
		转交其他 loader：将启动管理功能转交给其他 loader 负责
    依据 boot loader 的配置加载 Kernel ，Kernel 会开始侦测硬件与加载驱动程序；
    在硬件驱动成功后，Kernel 会主动呼叫 init 程序，而 init 会取得 run-level 资讯；
    init 运行 /etc/rc.d/rc.sysinit 文件来准备软件运行的作业环境 (如网络、时区等)；#调用/etc/init.d/
    init 运行 run-level 的各个服务之启动 (script 方式)；
    init 运行 /etc/rc.d/rc.local 文件；自定义自启脚本
    init 运行终端机模拟程序 mingetty 来启动 login 程序，最后就等待使用者登陆啦；

.configure：侦测程序来侦测使用者的作业环境， 以及该作业环境是否有软件开发商所需要的其他功能,常见出Makefile(记录了原始码如何编译的详细资讯)
make: 依据Makefile编译成可执行文件(gcc命令的集合)
make install：移动到指定路径



diff -Naur 旧文件 新文件 > /opt/diff.patch      #diff制作补丁文件的原理：告诉我们怎么修改第一个文件后能得到第二个文件
patch -p0 [旧文件] < /opt/diff.patch    #没加路径会提示，Reversed这种是因为反向补丁了，*.orig是备份  
	patch -p0 < patch_file 时，所在路径就是补丁文件（第二个路径*.old） 的diff比较路径 则升级的文件是『 /home/guest/example/expatch.old 』，如果『 patch -p1 < patch_file』，则升级的文件为『home/guest/example/expatch.old』，如果『patch -p4 < patch_file』则升级『expatch.old』，也就是说， -pxx 那个 xx 代表『拿掉几个斜线(/)』的意思！
patch -RE < test.patch //还原旧版本，反向修复


ldd 命令
ldd -v 函数库  #查看依赖
静态函式库:扩展名为 .a     编译的时候会直接整合到运行程序当中，所以利用静态函式库编译成的文件会比较大一些   运行档可以独立运行，但因为函式库是直接整合到运行档中， 因此若函式库升级时，整个运行档必须要重新编译才能将新版的函式库整合到程序当中
动态函式库:扩展名为 .so    在程序里面只有一个『指向 (Pointer)』的位置而已
将动态函式库加载高速缓存:  在 /etc/ld.so.conf 里面写下想要读入高速缓存当中的动态函式库所在的目录(是目录)
ldconfig  #将/etc/ld.so.conf 中动态函式库所在的目录下动态函数库加载到cache中
ldconfig -p   #查看


签名验证：md5sum / sha1sum  ： MD5 与 SHA1 加密机制（用法是一样的）


*.src.rpm: 这种安装后是一个源码包，再包装成rpm包(制作rpm包)
rpmbuild -ba rp-pppoe.spec  <==编译并同时产生RPM与SRPM文件
rpmbuild -bb rp-pppoe.spec  <==仅编译成 RPM 文件



平台名称	适合平台说明(硬件方面都可以向下兼容的)
i386		几乎适用於所有的 x86 平台，不论是旧的 pentum 或者是新的 Intel Core 2 与 K8 系列的 CPU 等等，都可以正常的工作！那个 i 指的是 Intel 兼容的 CPU 的意思，至於 386 不用说，就是 CPU 的等级啦！
i586		就是针对 586 等级的计算机进行最佳化编译。那是哪些 CPU 呢？包括 pentum 第一代 MMX CPU， AMD 的 K5, K6 系列 CPU (socket 7 插脚) 等等的 CPU 都算是这个等级；
i686		在 pentun II 以后的 Intel 系列 CPU ，及 K7 以后等级的 CPU 都属於这个 686 等级！ 由於目前市面上几乎仅剩 P-II 以后等级的硬件平台，因此很多 distributions 都直接释出这种等级的 RPM 文件。
x86_64		针对 64 位的 CPU 进行最佳化编译配置，包括 Intel 的 Core 2 以上等级 CPU ，以及 AMD 的 Athlon64 以后等级的 CPU ，都属於这一类型的硬件平台。
noarch		就是没有任何硬件等级上的限制。一般来说，这种类型的 RPM 文件，里面应该没有 binary program 存在， 较常出现的就是属於 shell script 方面的软件。

Alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。
Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。
RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。
GA:General Availability,正式发布的版本，在国外都是用GA来说明release版本的。
α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；
β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；
λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。

rpm：
--replacefiles 	使用时机： 如果在安装的过程当中出现了『某个文件已经被安装在你的系统上面』的资讯，又或许出现版本不合的信息 (confilcting files) 时，可以使用这个参数来直接覆盖文件。危险性： 覆盖的动作是无法复原的！所以，你必须要很清楚的知道被覆盖的文件是真的可以被覆盖喔！否则会欲哭无泪！
--test 	使用时机： 想要测试一下该软件是否可以被安装到使用者的 Linux 环境当中，可找出是否有属性相依的问题。范例为：
	rpm -ivh pkgname.i386.rpm --test
--justdb 	使用时机： 由於 RPM 数据库破损或者是某些缘故产生错误时，可使用这个选项来升级软件在数据库内的相关资讯。
--nosignature 	使用时机： 想要略过数码签章的检查时
--noscripts 	使用时机：不想让该软件在安装过程中自行运行某些系统命令。说明： RPM 的优点除了可以将文件放置到定位之外，还可以自动运行一些前置作业的命令，例如数据库的初始化。 如果你不想要让 RPM 帮你自动运行这一类型的命令，就加上他吧！
--prefix 新路径 	使用时机： 要将软件安装到其他非正规目录时。举例来说，你想要将某软件安装到 /usr/local 而非正规的 /bin, /etc 等目录， 就可以使用『 --prefix /usr/local 』来处理了
-Uvh 	后面接的软件即使没有安装过，则系统将予以直接安装； 若后面接的软件有安装过旧版，则系统自动升级至新版；
-Fvh 	如果后面接的软件并未安装到你的 Linux 系统上，则该软件不会被安装；亦即只有已安装至你 Linux 系统内的软件会被『升级』！

-q  ：仅查询，后面接的软件名称是否有安装；
-qa ：列出所有的，已经安装在本机 Linux 系统上面的所有软件名称；
-qi ：列出该软件的详细资讯 (information)，包含开发商、版本与说明等；
-ql ：列出该软件所有的文件与目录所在完整档名 (list)；
-qc ：列出该软件的所有配置档 (找出在 /etc/ 底下的档名而已)
-qd ：列出该软件的所有说明档 (找出与 man 有关的文件而已)
-qR ：列出与该软件有关的相依软件所含的文件 (Required 的意思)
-qf ：由后面接的文件名称，找出该文件属於哪一个已安装的软件；
查询某个 RPM 文件内含有的资讯：
-qp[icdlR]：注意 -qp 后面接的所有参数以上面的说明一致。但用途仅在於找出
	    某个 RPM 文件内的资讯

rpm -Va logrotate       列出目前系统上面所有可能被更动过的文件；
rpm -Vf /etc/crontab    是否有被更动过

rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5    #导入验证数据

rpm --rebuilddb   <==重建数据库


yum:
	-y ：当 yum 要等待使用者输入时，这个选项可以自动提供 yes 的回应；
	--installroot=/some/path ：将该软件安装在 /some/path 而不使用默认路径[查询工作项目]
	search  ：搜寻某个软件名称或者是描述 (description) 的重要关键字；
	list    ：列出目前 yum 所管理的所有的软件名称与版本，有点类似 rpm -qa；
	info    ：同上，不过有点类似 rpm -qai 的运行结果；
	provides：从文件去搜寻软件！类似 rpm -qf 的功能！


yum grouplist/groupinfo


核心模块：/lib/modules/$(uname -r)/kernel/ 
核心是直接被读入到主内存当中的



VNC的服务端目的是分享其所运行机器的屏幕， 服务端被动的允许客户端控制它。 VNC客户端（或Viewer） 观察控制服务端，与服务端交互。 VNC 协议 Protocol (RFB)是一个简单的协议，传送服务端的原始图像到客户端（一个X,Y 位置上的正方形的点阵数据）
	无法传输文件
RDP文件传输协议:RDP远程协议是一个多通道协议，让用户通过本地电脑连接远程服务器。大部分的Windows、Linux服务器都有相应的客户端

计算机与通信：C&C




