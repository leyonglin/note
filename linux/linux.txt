Linux Standard Base (LSB)等标准来规范开发者，以及目录架构的File system Hierarchy Standard (FHS)标准规范
Kernel + Softwares + Tools的可完全安装，我们称之为Linux distributio
Open Source (开放源码)的代表授权为GNU的GPL授权及BSD等等
POSIX是可携式操作系统接口(Portable Operating System Interface)的缩写，重点在规范核心与应用程序之间的接口


IDE硬盘机	/dev/hd[a-d]
SCSI/SATA/U盘硬盘机	/dev/sd[a-p]
鼠标	U盘: /dev/usb/mouse[0-15]
当前CDROM/DVDROM	/dev/cdrom
当前的鼠标	/dev/mouse


BIOS：启动主动运行的韧体，会认识第一个可启动的装置；
MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；
启动管理程序(boot loader)：一支可读取核心(grub)文件来运行的软件(linux/windows)；
核心文件：开始操作系统的功能...
由上面的说明我们会知道，BIOS与MBR都是硬件本身会支持的功能，至於Boot loader则是操作系统安装在MBR上面的一套软件了。由於MBR仅有446 bytes而已，因此这个启动管理程序是非常小而美的。 这个boot loader的主要任务有底下这些项目：

提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能！
加载核心文件：直接指向可启动的程序区段来开始操作系统；
转交其他loader：将启动管理功能转交给其他loader负责。

Linux distributions大多使用grub管理程序，必须要将他安装到MBR(boot sector)里面才行

GNOME(X windows)  kde

man 1, 5, 8这三个号码特别重要
man man
whatis cat
apropos cat
info info



pwd -P(显示实际路径)
cat  -A(显示特殊字符) -n
mkdir -p  -m(带权限)
rmdir 
cp -p(复制属性) -r(递归) -i
mv -i
basename  dirname
cat /etc/man.config | col -x | cat -A   #将tab(^I)转换成空格
cmd | expand -t 6 -   #将tab变成6个空格
join [-a1](左连接) [-a2](右连接) [-o 1.1/1.2..](文件.栏位) [-t ":"分隔符] file1 file2   找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备
paste /etc/passwd /etc/shadow  #将两个文件合并在一起
split [-bl] file PREFIX
	-b  ：后面可接欲分割成的文件大小，可加单位，例如 b, k, m 等；
	-l  ：以行数来进行分割。
	PREFIX ：代表前导符的意思，可作为分割文件的前导文字（名称）。
xargs

whereis which locate locale

stat
ls -lc filename         列出文件的 ctime
ls -lu filename         列出文件的 atime
ls -l filename          列出文件的 mtime


find   被攻击的时候可以看创建了什么文件
find / -u nobody -name test.txt -size +100k -mtime +4/4 -type s -perm +7000 -exec ls -l {} \;


单纯的 tar 功能仅是『打包』而已，亦即是将很多文件集结成为一个文件
tar -tf /root/etc.tar.gz                   #查看
tar -jxv -f /root/etc.tar.gz etc/shadow    #解压单个文件
tar -cavf /root/etc.tar.gz  /root/etc      #压缩  
tar -caPf ${backup_dir}/data_views_nginx_`date +%Y%m%d%H%M`.tar.gz  cms_9001/views/  \      #这里是 \[Enter] 
    -C /opt/apps/nginx/ conf --exclude "Geo*"  #-P压缩绝对路径(可以tf查看),日志结尾加时间戳，-C切换路径，这样或备份在同一级目录下(后面写绝对路径也可以，备份会加上路径)，排除Geo文件
  --newer-mtime=DATE   #仅备份比给定时间之后更新的
tar -cvf - /etc | tar -xvf -   #在管线命令当中，常常会使用到前一个命令的 stdout 作为这次的 stdin，将/etc下的文件压缩拷贝到当前目录下


dump：完整/增量备份文件系统
restore：恢复 
	restore -i -f /root/etc.dump      #交互恢复


编码转换：
	unix2doc	
	iconv -f 原本编码 -t 新编码 filename [-o newfile]	 #跟多
	
只要能够操作应用程序的接口都能够称为壳程序
shell有多种：bash是其中一个	
type

unset myname
env
set
export       #自定义变量转成环境变量
	global
	local
read
array 
declare / typeset :宣告变量的类型 (1.sum=100+300+50  2.declare -i sum=100+300+50  echo $sum)
	 declare -r sum(设置只读，不能修改和取消，还有别的选项)
ulimit -a



stty -a   # 可以设置热键  stty erase ^h 
set [-uvCHhmBx]
	-u  ：默认不激活。若激活后，当使用未配置变量时，会显示错误信息；
	-v  ：默认不激活。若激活后，在信息被输出前，会先显示信息的原始内容；
	-x  ：默认不激活。若激活后，在命令被运行前，会显示命令内容(前面有 ++ 符号)
	-h  ：默认激活。与历史命令有关；
	-H  ：默认激活。与历史命令有关；
	-m  ：默认激活。与工作管理有关；
	-B  ：默认激活。与刮号 [] 的作用有关；
	-C  ：默认不激活。若使用 > 等，则若文件存在时，该文件不会被覆盖。




HISTSIZE=1000
HISTIGNORE=”pwd:ls:ls -ltr:”
echo 'HISTTIMEFORMAT="%F %T "' >> ~/.bashrc
export HISTCONTROL = ignorespace              #第一个字符为空格的时候，不会被记录到history
history -c       #临时清理history（包括家目录下的history）
history -d num #删除指定history




--help
batch：系统有空时才进行背景任务，调用 at 来进行命令的下达
at ：at 是个可以处理仅运行一次就结束排程的命令（服务：atd）   权限：/etc/at.allow 或者 /etc/at.allow
crontab ：crontab 这个命令所配置的工作将会循环的一直进行下去  权限：/etc/cron.allow 或者 /etc/cron.deny   配置文件/etc/cron*
	*(星号)  ,(逗号)  -(减号)  /n(斜线)
anacron 其实也是透过 crontab 来运行 ：可唤醒停机期间的工作任务，以天为单位或者是在启动后立刻进行 anacron 的动作   配置文件：/etc/anacrontab



	
/var/log/secure, /var/log/messages


wall "I will shutdown my linux server..."  #广播


触发任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 ID ，称为 PID，同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限配置

程序是指令的集合，是进程运行的静态描述文本，而进程则是程序在系统上顺序执行时的动态活动

在 Linux 的程序呼叫通常称为 fork-and-exec 的流程 (注1)！程序都会藉由父程序以复制 (fork) 的方式产生一个一模一样的子程序， 然后被复制出来的子程序再以 exec 的方式来运行实际要进行的程序，最终就成为一个子程序的存在
exec：在当前bash下fork出一个bash运行程序，执行完成后退出

&   jobs -l     bg   fg   ctrl+z
 nohup [命令与参数] &

root 可随意调整自己或他人程序的 Nice 值，且范围为 -20 ~ 19 ；
一般使用者仅可调整自己程序的 Nice 值，且范围仅为 0 ~ 19 (避免一般用户抢占系统资源)；



一开始运行程序就立即给予一个特定的 nice 值：用 nice 命令；
	nice [-n 数字] command
调整某个已经存在的 PID 的 nice 值：用 renice 命令。
	renice [number] PID

找出进程pid
	pidof init





























