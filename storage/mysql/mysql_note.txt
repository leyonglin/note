
 查看性能：https://www.cnblogs.com/fyy-hhzzj/p/9044166.html
 mysqladmin status -uroot -p'admin' -P3306  -h127.0.0.1
 mysqladmin -h127.0.0.1 -uroot -p'admin'  extended-status [--relative --sleep=1]
  tps: Transactions Per Second，每秒事务数；   TPS=Com_commit/s + Com_rollback/s = Com_insert/s + Com_update/s + Com_delete/s  
  qps: Queries Per Second每秒查询数；          QPS = mysqladmin extended-status --relative --sleep=1|grep -w Questions = Com_select/s + Com_insert/s + Com_update/s + Com_delete/s
  Com_select/s = mysqladmin extended-status --relative --sleep=1|grep -w Com_select
  Com_select/s：平均每秒select语句执行次数
  Com_insert/s：平均每秒insert语句执行次数
  Com_update/s：平均每秒update语句执行次数
  Com_delete/s：平均每秒delete语句执行次数
 
 
 线上主从：
 数据库授权：在旧主库上授权	
 grant replication slave on *.* to myrync@'103.248.20.34' identified by 'MyryncCloud';
 并刷新权限flush privileges;	   
 做 主（旧主库）从（新主库） 从（新从库）
 主从从思路：
 1.主从的时候，mysqldump---备份一下mysql库(有授权信息)
 mysqldump -uroot -p -S /opt/data/data_16303/mysql.sock -P16303 -B mysql > /home/swadmin/mysql.sql
 2.每天有全备的，拷贝即可
   /backup/data_back/full
   innobackupex  --defaults-file=/opt/conf/my_16303.cnf  --use-memory=10G --compress --compress-threads=24  -uroot -p9tN6GFGK60Jk8BNkBJM611GwA66uDFeG  -S  /opt/data/data_16303/mysql.sock  /opt/src/upload/full
 3.同时拷贝旧站到新的主库和从库，
 4.恢复数据，(less /opt/src/upload/full/2018-05-20_12-33-46/xtrabackup_binlog_info)
   停止新主备站mysql服务并清空新主备站的数据目录
   解压：innobackupex --decompress --parallel=16 /opt/src/upload/full/2018-05-20_12-33-46/
   应用：innobackupex --apply-log --use-memory=4G  /opt/src/upload/full/2018-05-20_12-33-46/ 
   恢复：innobackupex --defaults-file=/opt/conf/my_slave_16303.cnf --use-memory=4G  --move(copy)-back  /opt/src/upload/full/2018-05-20_12-33-46/
   注意：改权限swadmin
   启动： mysqld --defaults-file=/opt/conf/my_16303.cnf  --user=swadmin &
 5.source  备份的mysql库 ，再flush privileges;
 6.新主从库先做主从 (在主库上show master status； 记住与上面步骤4的区别)
   CHANGE MASTER TO
   MASTER_HOST='154.223.1.77',
   MASTER_USER='myrync',
   MASTER_PASSWORD='MyryncCloud',
   MASTER_PORT=16303,
   MASTER_LOG_FILE='mysql-bin.000333',
   MASTER_LOG_POS=379096239;
 7.再在线上主库和新主库上做主从(偏移量参考步骤4)
 
 
 
 show variables like "%logs_days%";               查看变量
 set global expire_logs_days=7;                   设置变量
 flush logs;   &&  purge binary logs to 'bin.5';  &&   purge binary logs before '2017-05-01 13:09:51';    刷新binlogs日志&&删除bin.5之前日志&&删除指定时间之前日志 
 
 select * from information_schema.innodb_trx;    (INNODB_TRX表主要是包含了正在InnoDB引擎中执行的所有事务的信息，包括waiting for a lock和running的事务)
 
 select * from information_schema.innodb_lock_waits;  (INNODB_LOCKS表主要包含了InnoDB事务锁的具体情况，包括事务正在申请加的锁和事务加上的锁。)
 
 select * from information_schema.innodb_lock_waits;  (INNODB_LOCK_WAITS表包含了blocked的事务的锁等待的状态)
 
 
 show processlist；/ select * from information_schema.processlist  显示用户正在运行的线程,除了 root 用户能看到所有正在运行的线程外，其他用户都只能看到自己正在运行的线程，看不到其它用户正在运行的线程。除非单独个这个用户赋予了PROCESS 权限。
 按客户端 IP 分组，看哪个客户端的链接数最多
 select client_ip,count(client_ip) as client_num from (select substring_index(host,':' ,1) as client_ip from processlist ) as connect_info group by client_ip order by client_num desc;
 查看正在执行的线程，并按 Time 倒排序，看看有没有执行时间特别长的线程
 select * from information_schema.processlist where Command != 'Sleep' order by Time desc;
 找出所有执行时间超过 5 分钟的线程，拼凑出 kill 语句，方便后面查杀select concat('kill ', id, ';') from information_schema.processlist where Command != 'Sleep' and Time > 300 order by Time desc;
 
 set global read_only=0; ----> show variables like '%read_only'; ---> read_only OFF 
 
 查看从库状态：
 show slave status\G;
 
 测试授权用户连接：mysql  -u用户名  -h授权ip    -P端口 -p
 本地登陆：mysql  -uroot -p -S /opt/data/data_16303/mysql.sock [-P16303 -h127.0.0.1]
 导出全部数据库:mysqldump -uroot -p --all-databases > sqlfile.sql
 导出库：mysqldump -uroot -p -S /opt/data/data_16303/mysql.sock -P16303 -B gameplat_cms > /opt/src/upload/cms.sql
       [--single-transaction --master-data=2 -opt]
 导入库：mysql -uroot -p -S /opt/data/data_16303/mysql.sock gameplat_cms < cms.sql
 导出表：
 mysqldump -u 用户名 -p -S /opt/data/data_16303/mysql.sock 数据库名 表名 > 导出的文件名	
 mysqldump -uxxx -pxxx -hxx.xx.xx.xx -P 16303 -B luckydb --tables t1 t2 >./1.log
 mysql -uroot -D数据库名 -S /opt/data/data_16303/mysql.sock 表名
 
 
 查看授权：
 select user,host from mysql.user;
 show grants for user@host;
 show grants;
 
 授权：grant  all(select ,update) on  库名(*).表名(*)  to  'user'@'%' identified by "passwd" [with grant option];         
 撤销：revoke all on *.* from dba@localhost; 
 
 删除授权
 Delete FROM mysql.user Where User='gameplat_analysis_dev' and Host='$i';
 Delete FROM mysql.user Where User='gameplat_analysis_dev' and Host='103.86.87.194';
 
 
 删除账户及权限：>drop user user@'%';
 
 从库取消主从：stop slave；reset slave all;
 
 主从授权：grant replication slave on *.* to myrync@'$i' identified by 'MyryncCloud';
           flush privileges；
 
 查看信息：show master status;
 
 MySQL中source命令   mysql> source *.sql;     //导入数据 
 
 删除一行记录
 delete from db where localhost=103.86.87.193;
 删除表
 drop table 表名；
 
 Innobackupex：https://www.percona.com/downloads/[Percona-XtraBackup-LATEST/]
 增量备份的基础是InnoDB引擎使用了LSN机制，非InnoDB引擎不存在增量备份的说法，每次都是全备。
 全备文件：2018-05-20_12-33-46
 差异文件：/backup/data_back/incre/2018-05-20_12-33-46/*
 全备：innobackupex  --defaults-file=/opt/conf/my_16303.cnf  --use-memory=10G --compress --compress-threads=24  -uroot -p9tN6GFGK60Jk8BNkBJM611GwA66uDFeG  -S  /opt/data/data_16303/mysql.sock  /opt/src/upload/full
 差异备：innobackupex  --defaults-file=/opt/conf/my_16303.cnf  --use-memory=10G --compress --compress-threads=24  -uroot -p  -S  /opt/data/data_16303/mysql.sock  --incremental /backup/data_back/xtrabackup/incre/2018-05-20_12-33-46 --incremental-basedir /backup/data_back/xtrabackup/full/2018-05-20_12-33-46
 停止mysqld服务，清空data_16303/目录
 解压全备：innobackupex --decompress --parallel=16 /backup/data_back/full/2018-05-20_12-33-46/
 应用日志等待回滚：innobackupex --apply-log --use-memory=4G --redo-only /backup/data_back/full/2018-05-20_12-33-46/
 解压差异备份：innobackupex --decompress --parallel=16 /backup/data_back/incre/2018-05-20_12-33-46/2018-05-20_13-00-09/
 合并日志回滚：innobackupex --apply-log --use-memory=4G /backup/data_back/full/2018-05-20_12-33-46/  --incremental-dir=/backup/data_back/incre/2018-05-20_12-33-46/2018-05-20_13-00-09/
 可查看这个文件：less /backup/data_back/full/2018-05-20_12-33-46/xtrabackup_checkpoints---lsn是否最新(有变化)
 恢复数据：innobackupex --defaults-file=/opt/conf/my_16303.cnf --use-memory=4G  --copy(move)-back  /backup/data_back/full/2018-05-20_12-33-46/
 启动服务：mysqld --defaults-file=/opt/conf/my_16303.cnf  --user=swadmin &  （数据目录权限值得看一下）
 增量备份：
	innobackupex --user=root --password=123456 --no-timestamp --incremental-basedir=/backup/mysql/full --incremental /backup/mysql/01
	innobackupex --user=root --password=123456 --no-timestamp --incremental-basedir=/backup/mysql/01 --incremental /backup/mysql/02
 
 时点恢复:结合binlog将Mysql数据库恢复到指定时间点
 
 显示数据表结构:  desc 表名;   //   describe 表名;
 
 远程登陆mysql：mysql -hlocalhost -uroot -p -P3306 -S /opt/data/data_16303/mysql.sock
 使用gzip命令对备份文件进行压缩：：mysqldump phpbb_db_backup | gzip > /usr/backups
 
 
 mysql授权表共有5个表：user、db、host、tables_priv和columns_priv。
 user表列出可以连接服务器的用户及其口令，并且它指定他们有哪种全局（超级用户）权限。在user表启用的任何权限均是全局权限，并适用于所有数据库。例如，如果你启用了DELETE权限，在这里列出的用户可以从任何表中删除记录，所以在你这样做之前要认真考虑。
 db表列出数据库，而用户有权限访问它们。在这里指定的权限适用于一个数据库中的所有表。
 host表与db表结合使用在一个较好层次上控制特定主机对数据库的访问权限，这可能比单独使用db好些。这个表不受GRANT和REVOKE语句的影响，所以，你可能发觉你根本不是用它。
 tables_priv表指定表级权限，在这里指定的一个权限适用于一个表的所有列。
 columns_priv表指定列级权限。这里指定的权限适用于一个表的特定列。
 
 
 mysql> help          帮助命令
 mysql> help contents;  --->  help Account Management  --->  help CREATE USER  [查看库时命令 show create database ilanni;]  [关于主从：help transactions;]
 mysql> system  cmd   
 命令行执行命令：mysqld_safe/mysql –defaults-file=  -u用户 -p -S 本地sock文件 -e "sql命令"
 初始化：mysql_install_db  –help(–basedir=bin路径  –datadir=数据目录 –user=mysql )
 密码：mysqladmin -uroot [旧密码-p123456} password 456789  / [help set password; 修改密码]
 查看授权：mysql> use information_schema; --->  desc user_privileges; --->  select privilege_type from user_privileges; / show privileges;
 
 索引：
 alter table table_name add index index_name (column_list)/unique (column_list)/primary key (column_list) ;
 create [unique] index index_name on table_name (column_list) ;
 删除索引:
 drop index index_name on table_name ;
 alter table table_name drop index index_name/primary key ;
 
 
 for i in $ip;do
 expect << EOF
         spawn /opt/apps/mysql/bin/mysql -uroot -p -S /opt/data/data_16303/mysql.sock -e "    
         grant all privileges on gameplat_analysis.* TO 'gameplat_analysis_dev'@'$i' identified by 'xjVXkB>Q6JpB61r${rand_pass}';
         flush privileges;"
         expect "Enter password:" {send "9tN6GFGK60Jk8BNkBJM611GwA66uDFeG\r"}
         expect eof
 EOF
 done
 
 
 查库：show databases;   (库名区分大小写)
 位置：select database;
 建库：create database [if not exists] 库名 character set utf8;
 查看：show create database 库名;
 删库：drop database 库名; 
 进入指定库：use 库名;
 查表：show tables;
 查表:show create table 表名;
 建表：create table 表名(字段列表(字段名 数据类型, ...))character set utf8;
 删表：drop table 表名;
 表结构：desc 表名;
 插入：insert into 表名 values(值1),(值2)...;   或 insert into 表名(字段1,字段2,...) values(值1),(值2)...;
 查看: select *(字段,...) from 表名 where 条件(字段=(运算符)值,...);
 清空表中记录：delete from 表名;
 
 配置文件：
	[mysqld]
	charactr_set_server = utf8      #默认字符集
 
 数据类型：1.节省空间(varchar)    2.效率高(char)
	数值类型宽度(显示宽度，不够用0补充)和存储没有关系[有/无符号signed/unsigned],decimal(m,n)整数部分和小数部分分开存储
	字符类型宽度不够则无法存入
	枚举 单选enum  多选set
	时间 datetime(Null) = timestamp(系统时间) = date("年月日") + time("时分秒")
 
 日期时间函数：
 now()				返回服务器当前时间
 curldate()			当前日期
 date("datetime")	提取年月日
 time("datetime") 	提取时分秒
 year("datetime")	提取年
 
 日期时间运算：where * from 表名 where 字段名 运算符(now()-interval 时间间隔单位(1 day));
 
 表字段操作:alter table 表名 操作(add/drop/modify/rename/change) 字段名 数据类型 位置(first/after 字段名)；
 表记录操作：
	删除：delete from 表名 where 条件;
	更新：update 表名 set 字段1=值1, ...where 条件(可以使用括号()); 
 
 NULL：空值，只能用is、is not 去匹配
 "":空字符串，只能用 =  != 去匹配
 模糊查询(like)
	where 字段名 like 表达式
	_:匹配单个字符   %:匹配0到多个字符
	
  集合函数：
	avg(字段名)：平均值
	sum   max  min   count
	
 高级查询：表达式从行而下顺序结构
	select ...聚合函数 from 表名
	where  ...
	group by ...:给查询的结果进行分组
	having  ...：对查询结果进一步筛选
	order by  字段名 ASC/DESC : 给查询结果排序 
	limit [m,]n  ：显示查询记录的第m条开始，条数n

 distinct:不显示字段的重复值。语法：select distinct 字段1, 字段2 from 表名；
	distinct和from之间的所有字段值都相同才会去重
 
 约束constraint：保证数据的一致性，有效性
	分类：1.默认约束(default)    2.非空约束(not null)
 
 索引：对数据库中表的一列或多列的值进行排序的一种结构(BTree)
	优点：加快数据的检索速度
	缺点：1.数据更新时，索引需要动态维护，降低数据的维护速度    2.索引需要占用物理存储空间
 1.索引运行时间检测： set profiling=1；(show variables like "profiling")
 2.执行查询语句：
 3.查看执行时间：show profiles;
 4.选择一个字段创建索引:create index name on t1(name);
 5.再次执行查询语句并查看执行时间，进行比较
 
 1.普通索引(index):1.可设置多个字段,字段值无约束   2.把经常用来查询的字段设置为索引字段   3.key标志：MUL
		创建表时：create table t1(...,...,),index(name),index(id),...);
		已有表中：create index 索引名  on  表名(字段名)；
		查看：1.desc 表名;    2.show  index from 表名\G; 
		删除：drop index 索引名 on 表名;
 2.唯一索引(unique)&&自增长(auto_increment):1.可设置多个字段   2.字段值不允许重复，但可以为空值   3.key标志：UNI
		创建表时：create table t1(...,...,),unique(name),unique(id),...);
		已有表中：create unique index 索引名  on  表名(字段名)；
		查看：1.desc 表名;    2.show  index from 表名\G; 
		删除：drop index 索引名 on 表名;
 3.主键索引(primary key):1.只能有一个字段为主键字段   2.字段值不允许重复，也不能为NULL  
						 3.KEY标志：PRI    4.通常设置记录编号字段id，能够唯一锁定一条记录（自增长修改初始值：alter table 表名 AUTO_INCREMENT=10000;）
		创建表时：... id int primary key auto_increment      复合主键(两个id与name同时相同才会报错)：id int auto_increment,name varchar(20),primary key(id,name)
		已有表中:alter table 表名 add primary key(id);
		删除：1.删除自增长属性modify:alter table 表名 modify id int  2.alter table 表名 drop primary key;
 4.外键(foreign key):让当前的字段值在另一张表的范围内去选择，主从表字段数据类型要一致，主表：被参考字段是主键
		创建表时：...foreign key(参考字段名) reference 主表(被参考字段名) on delete 级联动作(cascade) on update 级联动作
		已有表时：alter table 表名 add foreign key(参考字段名) reference 主表(被参考字段名) on delete 级联动作 on update 级联动作
		删除外键：alter table 表名 drop foreign key 外键名;
		查看外键: show create table 表名;
		级联动作：1.cascade：数据级联删除，级联更新   2.restrict(默认)：从表中有相关联记录，不允许主表操作   3.set null：主表删除，更新，从表相关联记录字段值为NULL
 
 数据导入：把文件系统中内容导入到数据库中(.csv 可用execl表格打开)
	语法格式：load  data infile "文件名"  into table 表名 fields terminated by "分隔符" lines terminated by "\n";
	导入：1.在数据库中创建对应的表   2.1查看搜索路径show variables like "secure_file_priv"     2.2 执行数据导入,文件需在指定目录下
 数据导出：把输出到终端的数据表的记录导出到系统文件里
	语法格式： select ... from 表名 into outfile "文件名" fields terminated by "分隔符" lines terminated by "\n";
 
 表的复制：
	语法：create table 表名 select ... from 表名 where 条件;
 
 复制表结构：
	语法：create table 表名 select ... from 表名 where false;
 
 嵌套查询(子查询)：把内层的查询结果作为外层的查询条件
	语法：select ... from 表名 where 字段名 运算符 (select ... from 表名 where 条件);
 
 多表查询：
	1.笛卡尔积：不加where条件
		语法：select ... from 表1,表2;  
	2.加where条件
		语法: select ... from 表1,表2 where 条件;
 
 连接查询：多张表(比多表查询效率高)
	1.内连接(inner join)
		语法格式: select 字段名列表 from 表1 inner join 表2 on 条件 inner join 表2 on 条件 ...;
	2.外连接：没匹配到的用NULL填充
		2.1 左连接(left join):以左表为主，显示查询结果
			select 字段名列表 from 表1 left join 表2 on 条件 left join 表2 on 条件;			
		2.2 右连接(right join)：以右表为主显示查询结果
			select 字段名列表 from 表1 a right outer join 表2 on 条件;
			
 锁：解决客户端并发访问的冲突问题
	分类：
		锁类型：读锁(共享锁)：有读锁时，无法更改      写锁(互斥锁，排他锁)：有写锁时，无法查与更新
		锁粒度：行级锁row：Innodb          表级锁：MyISAM
 
 存储引擎(engine：处理表的处理器):
	查看所有：show engines;
	查看已有表：show create table 表名;
	指定：create table ... engine=myisam charset=utf8;  或 alter table 表名 engine=myisam;
  InnoDB:
		1.支持事务、外键、行级锁    
		2.共享表空间
			表名.frm:表结构和索引信息
			表名.idb:表记录
  Myisam：
		1.支持表级锁
		2.独享表空间
			表名.frm:表结构
			表名.MYD:表记录
			表名.MYI:索引信息
  Memory：数据存于内存中，重启表数据消失，表结构还在硬盘
  
	执行查询操作多的表使用Myisam     执行写操作多的表使用innodb
 
	账号管理：授权连接
		grant 权限列表 on 库名.表名 to "用户名"@"%(ip)" identified by "密码"  with grant option;
		权限列表：all privileges、select 库表.表名、update 库表.表名
 
	数据备份：命令行
		完整备份：mysqldump -u用户名 -p 源库名 > **.sql
			源库名：--all-databases         #所有库
					库名      				#单个库
					-B 库名1 库名2 ...      #多个库
					库名 表1 表2 ...		#多表
		恢复：mysql -u用户名 -p 目标库名 < **.sql		(恢复指定库需要先从库)
			mysql -u用户名 -p --one-database 库名 < **.sql (从全部备份中恢复一个库，先创建库)
			恢复库时，要先创建，如果已有库恢复，同名表数据会被覆盖，新增表不会被删除
		增量备份：

	调优：1.创建索引：(select where order by常涉及到的字段)
		2.选择合适存储引擎：执行查询操作多的表使用Myisam     执行写操作多的表使用innodb
		3.sql语句优化(避免全表扫描)
			1.where 子句尽量不适用 !=  ，否则全表扫描
			2.尽量避免NULL判断is null，否则全表扫描
				解决方法：字段设置not null/默认值0
			3.尽量避免用or连接条件，否则全表扫描
				解决方法：sql语句用union all拼接
			4.模糊查询尽量避免使用前置%  ,否则全表扫描
			5.尽量避免使用in和not in,否则全表扫描	
				优化前：select id from t1 where id in(1,2,3);
				优化后: select id from t1 where id between 1 and 4;
			6.不要使用select * ...
				解决方法：用具体字段代替* , 不返回用不到的字段
	事务和事务回滚：
		事务：一件事从开始发生到结束的整个过程，确保数据的一致性
		应用：1.begin;(自动关闭autocommit)    2. sql命令...      3.commit;(提交)/rollback;(回滚)

	图形化管理工具：workbench




 mysql逻辑架构：1.连接层  2.服务层  3.引擎层  4.存储层
	
 机读： from // on + join // where // group by // having // select // distinct // order by
 sql join: inner  left  right  
 
 	join连接：  1.左连接建右表索引，右连接建左表索引。2.尽可能减少join语句中的nestedloop的循环总次数："永远用小结果集驱动大的结果集" (个人觉得是explain中的rows) 
				3.保证join语句中被驱动表上join条件字段已经被索引   2.内存资源充足的前提下，使用joinbuffer的设置
	
 
 数据只进行逻辑删除：1.数据分析  2.方便索引
 索引(排序(按Seq_in_index进行排序)+检索/查询)能高效获取数据的数据结构。目的在于提高查询效率(B+树/多路搜索树)      #按Seq_in_index从小到大挨个关联进行排序)+检索/查询 利用索引这句话是本质
	索引分类：1.单值索引   2.唯一索引   3.复合索引		索引结构：1.Btree索引  2.Hash索引   3.full-text全文索引   4.R-Tree索引
	在数据之外，数据库系统维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据
		索引一般也很大，不能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上
		索引依据：1.频繁查找的字段应该建立索引  2.主键自动建立唯一索引  3.where条件里用不到的字段不建立索引   4.高并发下倾向于建立组合索引
				  5.查询中排序的字段，排序字段若通过索引去访问将大大提高速度  8.查询中统计或分组字段
				  1.经常更新的数据不适合做索引   2.表数据太少  3.重复内容多的数据列
		索引的建立根据业主而变化，是一个持续的过程
			优势：降低io和cpu消耗，提高效率和降低成本  缺点：增加存储空间，降低更新操作
		重构索引：
		覆盖索引：所查数据只需从索引中便能获取，即所查字段少于或等于复合索引个数 并且顺序一致
		
		
 expain：语法：explain sql语句;
		1.表的读取顺序  2.数据读取操作的操作类型  3.哪些索引可以使用  4.哪些索引被实际使用  5.表之间的引用  6.每张表有多少行被优化器查询
		2.各字段解释
		  | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
		    id：id相同，从上往下顺序执行，id不同，值越大，优先级越高，越先执行   # null表示从临时表取数据  <derived2>:id为2的衍生表(临时表：会增加负担，如两个数据交换) 
			  select_type：1.simple    2.primary    3.subquery   4.derived   5.union   6.union result ...
			  table：
		    type：    NULL       >   system   >  const    >     eq_ref       >       ref        >  range >   index  >  ALL        #最好是ref
			      不用查表/索引	   一行数据    主键=常量    唯一性索引扫描     非唯一性索引扫描    范围    索引扫描   全表扫描
			  possible_keys：指出MySQL能使用哪个索引在表中找到记录(如果是覆盖索引，则不会显示在这里)
		    Key：实际用到的索引(null为没建立索引或者索引失效)
			  key_len:不损失精确性(条件的多少)的情况下，长度越短越好 
			  ref:显示索引的那一列被使用,格式为"库.表.字段"，如果可能的话，是一个常数(const)，哪些列或常量被用于查找索引列上的值
			rows：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数(每张表有多少行被优化器查询)
			extra:包含不适合在其它列中显示但十分重要的额外信息
				Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”（很危险）            #order by要么不建索引，要么和索引的顺序和个数一致 Seq_in_index
				Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询（最危险） #group by要么不建索引，要么和索引的顺序和个数一致 Seq_in_index
				Using index：select的数据列值用从索引中就能够取得，不必读取数据行(覆盖索引，相当好)
				Using where：索引被用来执行索引键值的查找
				Using join buffer：使用了连接缓存
				impossible where:where子句的值总是false，不能用来获取任何元组
	
	创建：create index idx_article_ccv on article(id,comments,views);
    显示：show index from article;                                        # 按Seq_in_index进行排序，即1排序完成再排序2...，保证所查字段排序与索引排序一致
    删除：drop index idx_article_ccv on article
	创建：alter table 'book' add index u('card');


	索引原则：
		1.全值匹配:常量(=) 并且索引都用上
		2.最佳左前缀法则：索引了多列，要遵守最左前缀法则，即查询从索引的最左前列开始并且不跳过索引中的列
		3.不在索引列上做任何操作(计算/函数/or/类型转换..)会导致索引失效而转向全表扫描
		4.存储引擎不能使用索引中范围条件右边的列（中间条件使用范围条件,范围条件以后字段就无法索引）
		5.尽量使用覆盖索引：查询字段与索引字段一致或顺序一部分，少用select *
		6.mysql使用!=或者<>的时候无法使用索引会导致全表扫描
		7.is null , is not null 也无法使用索引
		8.like 使用通配符('%abc...') 索引失效，会变成全表扫描的操作 (可以使用覆盖索引解决)
		9.字符串不加单引号索引失效：即char/varchar要需要加'',原因是在索引上做了操作(类型转换)  #会导致行锁变成表锁，阻塞直到提交
		10.少用or，用它连接时会索引失效
		
		
	分析诊断工具：
		1.慢日志的开启并捕获(调优时开启)
		2.explain + 慢日志查询 
		3.show profile查询sql在mysql服务器里面的执行细节和生命周期情况
		4.sql数据库服务器的参数优化
	
	
	永远小表驱动大表：查询总次数一定情况下：使连接次数最少，一次连接查询次数最多
		select * from A where id in (select id from B)             			 #返回真正的数据
			等价于 1.for select id from B  2.for select * from A where A.id = B.id
			当B表的数据集必须小于A表的数据集时，用in优于exists
		select * from A where exists (select 1 from B where B.id = A.id)     #1代表常量，可以是别的。返回True/False 
			等价于 1.fro select * from A  2.for select * from B where B.id = A.id
			当A表的数据集必须小于B表的数据集时，用exists优于in
		A表和B表的ID字段应建立索引
	exists语法：将主查询的数据，放到子查询中做条件验证，根据验证结果(True/False)来决定主查询的数据结果是否得以保留
	
	
	order by子句：尽量使用index方式排序，避免使用FileSort方式排序            #mysql有两种排序，using index 和 filesort，filesort有双路排序(扫描两次磁盘)和单路排序(一次io,在内存排序) #单路排序有可能一次性取不完，即sort_buffer_size(会导致创建临时文件)和max_length_for_sort_data太小
				尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀	
	
	group by实质是先排序后进行分组，准找索引的最佳左前缀
	where 高于 having ，能现在where限定的条件不要去having限定
	
	
	慢日志：show variables like "%slow_query_log%";
			set global slow_query_log=1;  					#开启
			show variables like "long_query_time%";   		#大于该秒数记录慢日志，重开会话才能看到修改值 , select sleep(n);
			show global status like "%Slow_queries%";  	#查询当前系统中有多少条慢查询日志
	
	日志分析工具：mysqldumpslow
		s:排序方式  c:访问次数   l:锁定时间  r返回记录  t：查询时间  al:平均锁定时间  ar:平均返回记录数  at:平均查询时间  t:返回前面多少天的数据  g:搭配正则，忽略大小写 
		得到返回记录集最多的10个sql 						 mysqldumpslow -s -r -t 10 filename.log
		得到访问次数最多的10个sql      						 mysqldumpslow -s c -t 10 filename.log
		得到按照时间的前10条里面含有左连接的查询语句		 mysqldumpslow -s t -t 10 -g "left join" filename.log
	
	批量数据脚本
		函数和存储过程都是用sql脚本语言写的编程
			区别：函数有返回值，存储过程没有返回值
		show variables like 'log_bin_trust_function_creators';
	delimiter ;  #定义以;结尾则执行sql语句
	set autocommit=0;  #关闭自动提交
	
	show profile:参数默认是关闭状态，并保存最近15次的运行结果
		1.show variables like 'profiling';
		2.set profiling=on;
		3.运行sql
		4.查看结果：show profiles;               #获取Query_ID
		5.show profile cpu,block io,memory for query  Query_ID;  #诊断sql:能得到整个sql语句执行周期
		6.重要指标
			1.converting HEAP to MyISAM     #查询结果太大，内存不够用了，往磁盘上搬了
			2.creating tmp table            #创建临时表 1.拷贝数据到临时表 2.用完再删除(order by)
			3.copying to tmp table on disk  #把内存中临时表复制到磁盘，危险！！！
			4.locked
	
	全局查询日志：太耗费资源，只能在测试环境使用（模拟一段时间内的sql执行，出错的过程）
		general_log = 1                    #开启,之后编写的sql语句，将会记录到mysql库里的general_log表
		general_log_file = /path/logfile   #记录日志文件的路径
		log_output = file				   #输出日志
	
	
	锁是计算机协调多个进行或线程并发访问某一资源的机制
	分类：从对数据操作的类型：读锁(共享锁)和写锁(排它锁)
		  从对数据操作的粒度：行锁和表锁（介于两者之间的页锁,会出现死锁）
		依据：开销，加锁速度，死锁，粒度，并发性能
		行锁：偏向innodb存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高
		表锁：偏向myisam存储引擎，其它和行锁相反
	语法:1.lock table 表名字 read(write)   2.unlock tables;
		读锁：session1 为 table1 添加了read lock(读锁) 
				那么：session1只能读table1，不能修改table1,也不能读别的table(无锁状态)
					  非session1，能读table1，能读其它的table，但是如果更新table1的时候会一直阻塞，等待session1释放读锁
		写锁：session1 为 table1 添加了写锁
				那么：session1可读可写table1,但是不能读其它的table
					  非session1，不能读写table1，能读其它的table,要读table1会一直阻塞，等待session1释放写锁
	
	分析表锁：
		查看锁：show open tables;  (0表示没锁)
			show status like "table%";
				| Table_locks_immediate | 45   #产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1
				| Table_locks_waited    | 0    #出现表级锁定 争用而等待的次数(不能立即获得锁的次数)，此值高则说明存在着较严重的表级锁争用情况
		
		Myisam的读写锁调度是写优先，因为写锁后，大量更新会使查询很难得到锁，从而造成永远阻塞。因此不适合做写为主表的引擎	
	innodb和myisam的不同点：1.支持事务(transaction)  2.采用了行级锁
		事务和ACID(ACID是Atomic（原子性）Consistency（一致性）Isolation（隔离性）Durability（持久性）)
		并发事务处理带来的问题：
			1.更新丢失(AB同时修改同一数据，导致先更新的被后更新的覆盖(AB都读到5，但A先修改为6，B仍以5为数据进行修改))  
			2.脏读(A事务读取了B事务已修改但尚未提交的数据，并且在此数据基础上做了操作(B若回滚，则A读取的数据无效，不符合一致性要求))		
			3.不可重复读(一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现数据已修改/删除，即事务A读取到了事务B已经提交的修改的数据，不符合隔离性)  
			4.幻读(与不可重复读的区别是，事务A读取到了事务B已经提交的新增的数据)
		事务的隔离级别：1.未提交读Read uncommitted  2.已提交读(语句级)Read committed   3.可重复读(事务级)Repeatable read   4.可序列化(最高级的事务级)Serializable
			show variables like "tx_isolation";
		
		索引失效行锁可能变表锁(varchar类型不加'')
	
	间隙锁：当使用范围条件而不是相同条件检索数据，并请求共享或排它锁时，innodb会给符合条件的已有数据记录项加锁，对于键值在条件范围内并不存在的记录，叫做间隙(GAP)
		实例：1.update test set b='06' where a>1 and a<6;   2.insert into test values(2,'2000');   #a=2在1执行的时候是不存在的，但执行2的时候还是会被阻塞
	
	select * from test where a=8 for update;    # select ... for update;加锁锁定一行，其它的操作都会被阻塞，直至commit之后，锁会自动释放
	
	分析行锁：
		innodb存储引擎实现了行级锁定，性能消耗比表级锁高，但并发处理能力远由于Myisam表级锁定，但若使用不当，行锁变表锁，就很严重
			show status like 'innodb_row_lock%';
				| Innodb_row_lock_current_waits | 0     |   当前正在等待锁定的数量
				| Innodb_row_lock_time          | 0     |   从系统启动到现在锁定总时间长度
				| Innodb_row_lock_time_avg      | 0     |	每次等待所花平均时间
				| Innodb_row_lock_time_max      | 0     |	从系统启动到现在等待最长的一次所花时间
				| Innodb_row_lock_waits         | 0     |	系统启动后到现在总共等待的次数
	
	总结：
		1.尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁(varchar类型加'')
		2.合理设计索引，尽量缩小锁的访问
		3.尽可能减少检索条件，避免间隙锁
		4.尽量控制事务大小，减少锁定资源量和时间长度
		5.尽可能低级别事务隔离

	
	主从复制：master可以有多个slave，每个slave只有一个master，每个slave都有唯一一个服务器id
	主：配置路径log_bin(master将sql操作写入二进制文件叫做'二进制事件')
		配置路径log_err / basedir(根目录) / tmpdir / datadir(数据库目录) / read-only 
			    binlog_ignore-db(设置不要复制的数据库) / binlog-do-db(需要复制的目录)
	从：唯一id / log-bin(日志)
	
	
	
	DELIMITER $$
	CREATE PROCEDURE `partition_maintenance_all`(SCHEMA_NAME VARCHAR(32))
	BEGIN
					CALL partition_maintenance(SCHEMA_NAME, 'history', 7, 24, 14);
					CALL partition_maintenance(SCHEMA_NAME, 'history_log', 7, 24, 14);
					CALL partition_maintenance(SCHEMA_NAME, 'history_str', 7, 24, 14);
					CALL partition_maintenance(SCHEMA_NAME, 'history_text', 7, 24, 14);
					CALL partition_maintenance(SCHEMA_NAME, 'history_uint', 7, 24, 14);
					CALL partition_maintenance(SCHEMA_NAME, 'trends', 365, 24, 14);
					CALL partition_maintenance(SCHEMA_NAME, 'trends_uint', 365, 24, 14);
	END$$
	DELIMITER ;
	#CREATE PROCEDURE 语句：在数据库中创建用户定义的 SQL 过程。
	#以上代码部分的含义为(库名,表名,保存多少天的数据,每隔多久生成一个分区,本次生成多少分区）
		
		
	truncate table history;   ##删除整张表数据，但不会缩小表结构 
	optimize table tablename; ##删除数据后的优化 
	
	
	
	




	